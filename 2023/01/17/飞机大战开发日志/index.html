<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="LiXiJian">
    
    <title>
        
            飞机大战开发日志 |
        
        LiXiJian&#39;s Blog
    </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/css2.css">

    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"LiXiJian's Blog"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.4.4"};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LiXiJian&#39;s Blog
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <!-- Menu -->
                            <a class="" 
                                href="/" >
                                
                                    
                                        <i class="fa-regular fa-house"></i>
                                    
                                    HOME
                                
                            </a>
                            <!-- Submenu -->
                            
                        </li>
                    
                        <li class="menu-item">
                            <!-- Menu -->
                            <a class="" 
                                href="/archives" >
                                
                                    
                                        <i class="fa-regular fa-archive"></i>
                                    
                                    ARCHIVES
                                
                            </a>
                            <!-- Submenu -->
                            
                        </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class="" 
                       href="/" >
                         
                            
                                <i class="fa-regular fa-house"></i>
                            
                            HOME
                        
                    </a>
                </li>
                <!-- Submenu -->
                
            
                <li class="drawer-menu-item flex-center">
                    <a class="" 
                       href="/archives" >
                         
                            
                                <i class="fa-regular fa-archive"></i>
                            
                            ARCHIVES
                        
                    </a>
                </li>
                <!-- Submenu -->
                
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;">飞机大战开发日志</h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">LiXiJian</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-01-17 15:32:26</span>
        <span class="mobile">2023-01-17 15:32</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h2 id="一-配置easyx"><a href="#一-配置easyx" class="headerlink" title="一.配置easyx"></a>一.配置easyx</h2><p>操作：进入easyx官网下载，下载后点击，根据自己的vs再下载对应的版本，它会自动帮你配置好。</p>
<p>解释：easyx是针对c++的图形库，配置好它，才可以使用#include&lt;graphics.h&gt;</p>
<p>这个头文件有助于你创建游戏窗口，完成游戏元素的相关移动。</p>
<h2 id="二-游戏项目开始"><a href="#二-游戏项目开始" class="headerlink" title="二.游戏项目开始"></a>二.游戏项目开始</h2><h4 id="1-创建空项目，然后新建c-文件"><a href="#1-创建空项目，然后新建c-文件" class="headerlink" title="1.创建空项目，然后新建c++文件"></a>1.创建空项目，然后新建c++文件</h4><p>先附上源码，再逐步分析</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;//用于键盘输入函数
#include&lt;time.h&gt;
#include&lt;math.h&gt;

//引用 Windows Multimedia API
#pragma comment(lib,&quot;winmm.lib&quot;)

//游戏画面尺寸
#define HEIGHT 720
#define WIDTH 1280
#define PI 3.1415926

//定义图像
IMAGE img_bk, img_plane, temp_img,
img_ufoa, img_ufob, img_ufoc,
img_plane_bullet, img_ufoa_bullet, img_ufob_bullet;

//子弹结构体
typedef struct bullet
&#123;
    float x, y;//cpu算浮点型，速度有点慢，整型会好点
    float vx, vy;
    int damage;//伤害
    int isExist;//判断子弹是否需要删除
    bullet* pnext;//指向下一个子弹节点的指针
&#125;list;//取一个别名list

list* plane_bullet_list = NULL; // 飞机子弹列表的头节点
list* ufoa_bullet_list = NULL;  //UFOA的子弹列表的开头
list* ufob_bullet_list = NULL;  //UFOB的子弹列表的开头

int score = 0;
int game_over = 0;//等于0游戏不结束

//bullet mybullet_buf[1000];
//int mybullet_idx = 0;//当前射击子弹的数目 索引 下标

//向量的结构体
struct vector
&#123;
    float x, y;
&#125;;

//三角形的结构体
struct triangle
&#123;
    float ax, ay, bx, by, cx, cy;
&#125;;

//定义飞机结构体
struct aircraft
&#123;
    int x, y;
    int width;
    int height;
    int speed;
    int life;
    int new_born_flg;//是否重生

&#125;;

//定义飞行器
aircraft plane, ufoa, ufob, ufoc;



//按键输入的枚举列表
enum GAMEINPUT
&#123;
    //用0x十六进制表示
    NOINPUT=0X0,
    UPINPUT=0X1,
    DOWNINPUT=0X2,
    LEFTINPUT=0X4,
    RIGHTINPUT=0X8,
    FIREINPUT=0X10
&#125;;
int input = NOINPUT;//判断输入变量
//一个变量储存多个状态

int PLANE_LIFE = 100;
int UFOA_LIFE = 1500;
int UFOB_LIFE = 150;
int UFOC_LIFE = 100;


//函数声明
void dataInit();
void loadRes();
void showAircraft();
void drawAlpha(IMAGE* dstimg, int x, int y, IMAGE* srcimg);
void getInput();
void dealInput();
void ctrlFps(int start_time);
void ufoaMove();
void ufobMove();
void ufocMove();
void listPushBack(list** pplist, list* newNode);
list* creatPlaneBullet(float vx, float vy);
void listChangeXY(list** pplist);
void listRemoveNode(list** pplist);
void showBullet();
list* creatUFOA_Bullet(float vx, float vy);
list* creatUFOB_Bullet(float vx, float vy);

void bulletHitUFO(aircraft* tmp);
void aircraftReborn(aircraft* tmp, int life);
void aircraftLifeJudge();

void clearBullet(list** pplist);
void clearAllBullet();

//处理三角形相关函数
vector getVector(float x1, float y1, float x2, float y2);//生成向量
float crossProduct(vector a, vector b);//2个向量的叉乘
int isPointInTriangle(triangle tri, float x, float y);//判断点(x,y)是否在三角形内
triangle getPlaneTriangle();//构建一个三角形，用于碰撞判断

//碰撞相关函数
void bulletHitPlane(list* bullet_list);//判断UFO的子弹是否击中飞机
void bulletHitUFO(aircraft* tmp);//判断飞机的子弹是否击中UFO
void ufoCrash(aircraft* tmp);//UFO是否与飞机碰撞
void ufosCrashJudge();//整个UFO是否与飞机碰撞

void showScore(int x, int y, int score);//显示分数
void showLife(int x, int y, int life);
void showBeginPicture();//开场界面
void showGameOver();//结束界面

//音乐音效函数
void playBgmMusic();
void playBoomMusic();
void playBoom2Music();
void playBoom3Music();
void playShootMusic();


int main()
&#123;
    dataInit();//初始化所有飞机，设置飞机坐标
    initgraph(WIDTH, HEIGHT);//创建绘图窗口
    loadRes();
    clock_t start_time;//clock_t 是用来保存时间的数据类型，返回的单位是毫秒
    //playBgmMusic();
    showBeginPicture();
    //解决画面闪烁
    BeginBatchDraw();//开始批量绘图
    srand(time(NULL));//随机数种子
    while (1)
    &#123;
        start_time = clock();
        ufoaMove();
        ufobMove();
        ufocMove();
        getInput();//获取输入
        dealInput();//调整飞机位置，射击
        showAircraft();//显示飞机
        aircraftLifeJudge();
        showBullet();
        ufosCrashJudge();
        putimage(0, 0, &amp;temp_img);//绘制制定图像
        //Sleep(10);//休眠10ms
        showScore(400, 0, score);
        showLife(1000, 0, plane.life);
        ctrlFps(start_time);//动态调整休眠时间,控制Fps在60左右
        FlushBatchDraw();//执行此语句才绘画出
        if (game_over)
        &#123;
            showGameOver();
        &#125;
    &#125;
    EndBatchDraw();
    
   
    _getch();//使程序暂停,可以看到执行结果，不然会一闪而过
    closegraph();//关闭绘图窗口

    return 0;
&#125;

//同时获取多个输入，操作飞机
void getInput()
&#123;
    int reload_time = 100;//装填时间，100ms 即每一百毫秒才能射击一次子弹
    static int fire_start = 0;//静态变量，储存开火的时间
    int tmp = clock();//当前时间

    //判断获取键值且最高为1
    if (GetAsyncKeyState(&#39;W&#39;) &amp; 0x8000)
    &#123;
        input |= UPINPUT;// 等价 input =input|UPINPUT  |是按位或操作，就是只要有一个1就是1，两个都是0才是0
    &#125;
    if (GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000)
    &#123;
        input |= DOWNINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000)
    &#123;
        input |= LEFTINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;D&#39;) &amp; 0x8000)
    &#123;
        input |= RIGHTINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;K&#39;) &amp; 0x8000)
    &#123;
        if (tmp - fire_start &gt;= reload_time)//每100ms发射一次
        &#123;
            input |= FIREINPUT;
            fire_start = tmp;
        &#125;
            
    &#125;
&#125;

//
void dealInput()
&#123;
    if ((input &amp; UPINPUT)&amp;&amp;(plane.y&gt;=0))//加限制，不出边界
    &#123;
        plane.y -= plane.speed;
    &#125;
    if ((input &amp; LEFTINPUT)&amp;&amp; (plane.x &gt;= 0))
    &#123;
        plane.x -= plane.speed;
    &#125;
    if ((input &amp; DOWNINPUT)&amp;&amp;(plane.y &lt;=HEIGHT-120))
    &#123;
        plane.y += plane.speed;
    &#125;
    if ((input &amp; RIGHTINPUT )&amp;&amp; (plane.x &lt;=WIDTH-120))
    &#123;
        plane.x += plane.speed;
    &#125;
    if (input &amp; FIREINPUT)
    &#123;
        playShootMusic();
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(0, -20));
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(-10, -17.32));//30° 散弹左 20*cos30°约等于17.32
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(10, -17.32));//散弹右
        /*mybullet_buf[mybullet_idx].x = plane.x + plane.width / 2;
        mybullet_buf[mybullet_idx].y = plane.y;
        mybullet_buf[mybullet_idx].vx = 0;
        mybullet_buf[mybullet_idx].vy = -20;//子弹坐标在减少
        mybullet_idx++;*/
        
    &#125;
    input = NOINPUT;//清零
&#125;

//飞行器数据的初始化
void dataInit()
&#123;
    //坐标
    plane.x = WIDTH/2;
    plane.y = HEIGHT-200;
    plane.width = 80;
    plane.height = 80;
    plane.speed = 10;
    plane.new_born_flg = 1;

    ufoa = &#123; 0,0 &#125;;//书写的第二种形式
    ufoa.width = 300;
    ufoa.height = 150;
    ufoa.speed = 3;
    ufoa.new_born_flg = 1;

    ufob = &#123; 300,0 &#125;;
    ufob.width = 150;
    ufob.height = 50;
    ufob.speed = 8;
    ufob.new_born_flg = 1;

    ufoc = &#123; 450,200&#125;;
    ufoc.width = 100;
    ufoc.height = 60;
    ufoc.speed = 15;
    ufoc.new_born_flg = 1;

    //生命值
    plane.life = PLANE_LIFE;
    ufoa.life = UFOA_LIFE;
    ufob.life = UFOB_LIFE;
    ufoc.life = UFOC_LIFE;
&#125;


//载入资源
void loadRes()
&#123;
    loadimage(&amp;img_bk, &quot;res\\background.png&quot;);//从文件中读取图像
    loadimage(&amp;temp_img, &quot;res\\background.png&quot;);
    loadimage(&amp;img_plane, &quot;res\\plane.png&quot;);
    loadimage(&amp;img_ufoa, &quot;res\\ufoa.png&quot;);
    loadimage(&amp;img_ufob, &quot;res\\ufob.png&quot;);
    loadimage(&amp;img_ufoc, &quot;res\\ufoc.png&quot;);
    loadimage(&amp;img_plane_bullet, &quot;res\\plane_bullet.png&quot;);
    loadimage(&amp;img_ufoa_bullet, &quot;res\\ufoa_bullet.png&quot;);
    loadimage(&amp;img_ufob_bullet, &quot;res\\ufob_bullet.png&quot;);
&#125;

//绘制所有的飞机
void showAircraft()
&#123;
    drawAlpha(&amp;temp_img, 0, 0, &amp;img_bk);
    drawAlpha(&amp;temp_img, plane.x, plane.y, &amp;img_plane);
    drawAlpha(&amp;temp_img, ufoa.x, ufoa.y, &amp;img_ufoa);
    drawAlpha(&amp;temp_img, ufob.x, ufob.y, &amp;img_ufob);
    drawAlpha(&amp;temp_img, ufoc.x, ufoc.y, &amp;img_ufoc);

&#125;

// 根据透明度绘图(透明贴图显示)
void drawAlpha(IMAGE* dstimg, int x, int y, IMAGE* srcimg)
&#123;
    // 变量初始化
    DWORD* dst = GetImageBuffer(dstimg);
    DWORD* src = GetImageBuffer(srcimg);
    int src_width = srcimg-&gt;getwidth();
    int src_height = srcimg-&gt;getheight();
    int dst_width = (dstimg == NULL ? getwidth() : dstimg-&gt;getwidth());
    int dst_height = (dstimg == NULL ? getheight() : dstimg-&gt;getheight());

    // 计算贴图的实际长宽
    int iwidth = (x + src_width &gt; dst_width) ? dst_width - x : src_width;		// 处理超出右边界
    int iheight = (y + src_height &gt; dst_height) ? dst_height - y : src_height;	// 处理超出下边界
    if (x &lt; 0) &#123; src += -x;				iwidth -= -x;	x = 0; &#125;				// 处理超出左边界
    if (y &lt; 0) &#123; src += src_width * -y;	iheight -= -y;	y = 0; &#125;				// 处理超出上边界

    // 修正贴图起始位置
    dst += dst_width * y + x;
    // 实现透明贴图
    for (int iy = 0; iy &lt; iheight; ++iy)
    &#123;
        for (int i = 0; i &lt; iwidth; ++i)
        &#123;
            int sa = ((src[i] &amp; 0xff000000) &gt;&gt; 24);//获取阿尔法值
            if (sa != 0)//假如是完全透明就不处理
                if (sa == 255)//假如完全不透明则直接拷贝
                    dst[i] = src[i];
                else//真正需要阿尔法混合计算的图像边界才进行混合
                    dst[i] = ((((src[i] &amp; 0xff0000) &gt;&gt; 16) + ((dst[i] &amp; 0xff0000) &gt;&gt; 16) * (255 - sa) / 255) &lt;&lt; 16) | ((((src[i] &amp; 0xff00) &gt;&gt; 8) + ((dst[i] &amp; 0xff00) &gt;&gt; 8) * (255 - sa) / 255) &lt;&lt; 8) | ((src[i] &amp; 0xff) + (dst[i] &amp; 0xff) * (255 - sa) / 255);
        &#125;
        dst += dst_width;
        src += src_width;
    &#125;
&#125;

//控制刷新率
void ctrlFps(int start_time)
&#123;
    clock_t running_time = clock() - start_time;// 获取当前时间，算出时间差
    if (20 - running_time &gt;= 0)//防止休眠函数使用负数
        Sleep(20 - running_time);//希望每执行一次任务都是13s，如果超过13s就不休眠了，继续执行
    TCHAR time_text[50];
    int FPS = 1000 / (clock() - start_time);//计算刷新率
    _stprintf_s(time_text, &quot;FPS:%d&quot;, FPS);
    settextstyle(40, 0, &quot;黑体&quot;); //为了演示，显示fps字体大小不宜太大
    outtextxy(0, 0, time_text);
&#125;

//大UFO缓慢向前移动，到达一定的位置回去
void ufoaMove()
&#123;
    static int dir = 1;//1表示前进
    static int cnt = 0;//计数器
    int ufoa_reload_cnt = 80;//发射子弹的计数器，数值越小发射子弹越快
    int ufoa_fire_num = 20;  //UFOA共发射多少路子弹
    if (1 == ufoa.new_born_flg)//新出生的ufoa，重置x,y的坐标
    &#123;
        ufoa.new_born_flg = 0;
        ufoa.x = rand() % (WIDTH - ufoa.width);//确保在屏幕内
        ufoa.y = -50;//从最上方出生
    &#125;
    if (ufoa.y &gt; 200)
    &#123;
        dir = 0;//0表示后退
    &#125;
    else if (ufoa.y &lt; -150)
    &#123;
        dir = 1;
        ufoa.new_born_flg = 1;//重生
    &#125;
    if (1 == dir)
    &#123;
        ufoa.y += ufoa.speed;
    &#125;
    else
    &#123;
        ufoa.y -= ufoa.speed;
    &#125;

    //cnt到达指定的间隔以后，转圈发射子弹
    if (++cnt % ufoa_reload_cnt == 0)
    &#123;
        for (int i = 0; i &lt; ufoa_fire_num; i++)
        &#123;
            float angle = i * 2 * PI / ufoa_fire_num;
            float vx = 4 * sin(angle);
            float vy = 4 * cos(angle);
            listPushBack(&amp;ufoa_bullet_list, creatUFOA_Bullet(vx, vy));
        &#125;
        
    &#125;
    if (cnt &gt; 99999)//避免溢出
        cnt = 0;


&#125;

//UFOB左右快速移动，慢速向下移动
void ufobMove()
&#123;
    static int step = ufob.speed;//spep表示方向与速度
    static int cnt = 0;
    int ufob_reload_cnt = 60;//UFOb  发射子弹的计数器，数值越小发射子弹越快
    if (1 == ufob.new_born_flg)//新出生的ufob ，重置x,y的坐标
    &#123;
        ufob.new_born_flg = 0;
        ufob.x = rand() % (WIDTH - ufob.width);
        ufob.y = -ufob.height;
    &#125;
    //水平撞墙返回
    if ((ufob.x &lt;= 0) || (ufob.x + ufob.width &gt;= WIDTH))
        step = -step;
    ufob.x += step;
    ufob.y++;
    //超出下边界，重生，y坐标重置，x坐标随机
    if (ufob.y &gt;= HEIGHT)
        ufob.new_born_flg = 1;
    //往下发射子弹
    if (++cnt % ufob_reload_cnt == 0)
    &#123;
        listPushBack(&amp;ufob_bullet_list, creatUFOB_Bullet(0, 5));
    &#125;
    if (cnt &gt; 999999) cnt = 0;//当计数器超过999999 进行清零
&#125;


//ufoc撞向飞机
void ufocMove()
&#123;
    //显卡擅长做浮点型运算
    static float dist_x = 0, dist_y = 0;//ufoc出生时，记录与飞机的横竖距离
    static float tmp_x = 0, tmp_y = 0;//储存x,y坐标的临时变量，浮点型方便计算
    static float vx = 0, vy = 0;//水平和竖直方向的速度
    float step = 1000 / ufoc.speed;//调整UFO速度
    if (1 == ufoc.new_born_flg)
    &#123;
        ufoc.new_born_flg = 0;
        tmp_x = rand() % (WIDTH - ufoc.width);
        tmp_y = -ufoc.height;
        dist_x = plane.x - tmp_x;
        dist_y = plane.y - tmp_y;
        vx = dist_x / step;
        vy = dist_y / step;
    &#125;
    tmp_x += vx;
    tmp_y += vy;
    ufoc.x = (int)(tmp_x + 0.5);//加0.5相当于四舍五入
    ufoc.y = (int)(tmp_y + 0.5);
    //边界判断，可以超出画面，但不超出太多
    if (ufoc.x &lt; -ufoc.width)
        ufoc.new_born_flg = 1;
    else if (ufoc.x &gt; WIDTH + ufoc.width)
        ufoc.new_born_flg = 1;
    //超出下边界，重生，y坐标重置，x坐标随机
    if (ufoc.y &gt;= HEIGHT)
        ufoc.new_born_flg = 1;

&#125;

/*
//子弹移动
void bulletMove()
&#123;
    for (int i = 0; i &lt; mybullet_idx; i++)
    &#123;
        mybullet_buf[i].x += mybullet_buf[i].vx;
        mybullet_buf[i].y += mybullet_buf[i].vy;
    &#125;
&#125;

//显示发射的子弹
void showBullet()
&#123;
    bulletMove();
    for (int i = 0; i &lt; mybullet_idx; i++)
    &#123;
        drawAlpha(&amp;temp_img, mybullet_buf[i].x, mybullet_buf[i].y, &amp;img_plane_bullet);
    &#125;
&#125;
*/

/*&amp;list 传链表地址才能改变链表
链表list又由头结点地址决定
所以用二级指针传地址*/
//在某链表尾部插入一个数据
void listPushBack(list** pplist, list* newNode)//** pplist 指向地址的指针
&#123;
    if (*pplist == NULL)//如果链表为空，那么新增的节点就是第一个
    &#123;
        *pplist = newNode;
        return;
    &#125;
    list* cur = *pplist;//指向头结点
    while (cur-&gt;pnext != NULL)//找到最后一个节点
    &#123;
        cur = cur-&gt;pnext;
    &#125;
    cur-&gt;pnext = newNode;//插入新的节点
&#125;

//飞机发射的子弹，增加一个节点
list* creatPlaneBullet(float vx,float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针用箭头-&gt;
    //结构体用点
    p-&gt;x= plane.x + plane.width / 2+10;
    p-&gt;y = plane.y;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 50;
    return p;

&#125;

//改变飞机子弹坐标
void listChangeXY(list** pplist)
&#123;
    if (*pplist == NULL)
        return;
    list* cur = *pplist;//curret指向第一个节点
    while (cur != NULL)//遍历链表
    &#123;
        cur-&gt;x += cur-&gt;vx;
        cur-&gt;y += cur-&gt;vy;
        //判断子弹是否离开视野
        if ((cur-&gt;y &lt; -20) || (cur-&gt;y &gt; HEIGHT) || (cur-&gt;x &gt; WIDTH) || (cur-&gt;x &lt; 0))
            cur-&gt;isExist = 0;
        cur = cur-&gt;pnext;//指向下一节点
    &#125;

&#125;

//删除链表中isExist为0的节点
void listRemoveNode(list** pplist)
&#123;
    if (*pplist == NULL)//如果链表为空，就没有可删除的节点了
        return;
    list* cur = *pplist;//curret先指向第一个节点
    list* prev = NULL;  //previous指向上一个节点的指针
    while (cur != NULL)//遍历链表
    &#123;
        if (cur-&gt;isExist == 0)//判断节点是否需要删除
        &#123;
            if (*pplist == cur)//如果删除的是第一个节点
            &#123;
                *pplist = cur-&gt;pnext;  //更改链表的地址，让下一个节点作为头结点 ，如果没有节点，则链表为空
                free(cur);             //释放当前节点（第一个节点的）空间
                cur = *pplist;         //让cur指向下一个节点
            &#125;
            else
            &#123;
                prev-&gt;pnext = cur-&gt;pnext;  //记录下一个节点的地址
                free(cur);                 //释放当前节点空间
                cur = prev;                //当前节点变成前一个节点
            &#125;
        &#125;
        else //如果不需要删除节点，储存当前节点为前一个节点，然后指向下一个节点
        &#123;
            prev = cur;
            cur = cur-&gt;pnext;
        &#125;
    &#125;
&#125;

//绘制发出来的子弹
void showBullet()
&#123;
    //飞机发射的子弹
    listChangeXY(&amp;plane_bullet_list);//计算子弹新的位置
    bulletHitUFO(&amp;ufoc);//判断子弹是否击中，更改生命和子弹状态
    bulletHitUFO(&amp;ufoa);
    bulletHitUFO(&amp;ufob);
    listRemoveNode(&amp;plane_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = plane_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x, cur-&gt;y, &amp;img_plane_bullet);
    &#125;

    //ufoa发出的子弹
    listChangeXY(&amp;ufoa_bullet_list);//计算子弹新的位置
    listRemoveNode(&amp;ufoa_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = ufoa_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x - 10, cur-&gt;y - 10, &amp;img_ufoa_bullet);
    &#125;

    //ufob发出的子弹
    listChangeXY(&amp;ufob_bullet_list);//计算子弹新的位置
    listRemoveNode(&amp;ufob_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = ufob_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x - 15, cur-&gt;y - 30, &amp;img_ufob_bullet);
    &#125;

    //判断敌机子弹是否击中，更改飞机生命和子弹状态
    bulletHitPlane(ufoa_bullet_list);
    bulletHitPlane(ufob_bullet_list);
&#125;

//ufoa发射的子弹，增加一个节点
list* creatUFOA_Bullet(float vx, float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针引用结构体成员用箭头-&gt;
    //结构体引用成员用点
    p-&gt;x = ufoa.x + ufoa.width / 2 ;
    p-&gt;y = ufoa.y;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 10;
    return p;

&#125;

//ufob发射的子弹，增加一个节点
list* creatUFOB_Bullet(float vx, float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针用箭头-&gt;
    //结构体用点
    p-&gt;x = ufob.x + ufob.width / 2-10;
    p-&gt;y = ufob.y+30;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 20;
    return p;

&#125;

//判断飞机的子弹是否击中UFO，执行相应的加分与减命的操作
void bulletHitUFO(aircraft* tmp)
&#123;
    for (list* cur = plane_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        //子弹在UFO的矩形图片内时，认为击中
        if ((cur-&gt;x &gt; tmp-&gt;x) &amp;&amp; (cur-&gt;x &lt; tmp-&gt;x + tmp-&gt;width))
        &#123;
            if ((cur-&gt;y &gt; tmp-&gt;y) &amp;&amp; (cur-&gt;y &lt; tmp-&gt;y + tmp-&gt;height))
            &#123;
                tmp-&gt;life -= cur-&gt;damage;//飞行器生命值 - 子弹的伤害
                cur-&gt;isExist = 0;  //清除子弹的存在标记
            &#125;
        &#125;
    &#125;
&#125;

//飞行器重生 参数为飞行器的地址，以及重生的血量
void aircraftReborn(aircraft* tmp, int life)
&#123;
    tmp-&gt;new_born_flg = 1;
    tmp-&gt;life = life;
&#125;

//飞行器生存判断
void aircraftLifeJudge()
&#123;
    if (ufoa.life &lt;= 0)
    &#123;
        //aircraftReborn(&amp;ufoa, ufoa.life);//这是错误写法
        playBoomMusic();
        aircraftReborn(&amp;ufoa, UFOA_LIFE);
        score += UFOA_LIFE;
    &#125;
    if (ufob.life &lt;= 0)
    &#123;
        playBoom2Music();
        aircraftReborn(&amp;ufob, UFOB_LIFE);
        score += UFOB_LIFE;
    &#125;
    if (ufoc.life &lt;= 0)
    &#123;
        playBoom3Music();
        aircraftReborn(&amp;ufoc, UFOC_LIFE);
        score += UFOC_LIFE;
    &#125;
    if (plane.life &lt;= 0)
    &#123;
        game_over = 1;
    &#125;

&#125;

//传入2组坐标，生成向量
vector getVector(float x1, float y1, float x2, float y2)
&#123;
    vector tmp;
    tmp.x = x2 - x1;
    tmp.y = y2 - y1;
    return tmp;
&#125;

//2个向量的叉乘，结果仍然是向量，正负可以表示方向
float crossProduct(vector a, vector b)
&#123;
    float tmp = a.x * b.y - a.y * b.x;
    return tmp;
&#125;

//判断点(x,y)是否在三角形内
int isPointInTriangle(triangle tri, float x, float y)
&#123;
    vector pa = getVector(tri.ax, tri.ay, x, y);//向量pa，是a-p
    vector pb = getVector(tri.bx, tri.by, x, y);//向量pb，是b-p
    vector pc = getVector(tri.cx, tri.cy, x, y);//向量pc，是c-p
    float t1 = crossProduct(pa, pb);
    float t2 = crossProduct(pb, pc);
    float t3 = crossProduct(pc, pa);
    return t1 * t2 &gt;= 0 &amp;&amp; t1 * t3 &gt;= 0 &amp;&amp; t2 * t3 &gt;= 0;
&#125;

//根据飞机图片的x 与 y坐标 来构建一个三角形，用于碰撞判断
triangle getPlaneTriangle()
&#123;
    triangle tmp;
    //a 是最上边的点，b 是右下， c是左下。
    tmp.ax = plane.x + plane.width / 2;
    tmp.ay = plane.y;
    tmp.bx = plane.x + plane.width;
    tmp.by = plane.y + plane.height;
    tmp.cx = plane.x;
    tmp.cy = plane.y + plane.height;
    return tmp;
&#125;

//判断UFO的子弹是否击中飞机，执行相应的加分与减命的操作,参数是UFO的子弹链表
void bulletHitPlane(list* bullet_list)
&#123;
    for (list* cur = bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        //子弹在飞机的矩形图片内时，再判断是否在飞机的三角形内，减少计算量
        if ((cur-&gt;x &gt; plane.x) &amp;&amp; (cur-&gt;x &lt; plane.x + plane.width))
        &#123;
            if ((cur-&gt;y &gt; plane.y) &amp;&amp; (cur-&gt;y &lt; plane.y + plane.height))
            &#123;
                triangle tri = getPlaneTriangle();//获取飞机的三角形参数
                if (isPointInTriangle(tri, cur-&gt;x, cur-&gt;y))//子弹与飞机相撞
                &#123;
                    plane.life -= cur-&gt;damage;
                    cur-&gt;isExist = 0;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

//UFO是否与飞机碰撞  判断UFO下方中间的点,中间偏左与中间偏右的点，是否处于飞行器的范围内
void ufoCrash(aircraft* tmp)
&#123;
    triangle tri = getPlaneTriangle();//获取飞机的三角形参数
    if (isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width / 2, tmp-&gt;y + tmp-&gt;height)
        || isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width / 4, tmp-&gt;y + tmp-&gt;height / 2)
        || isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width - tmp-&gt;width / 4, tmp-&gt;y + tmp-&gt;height / 2))
    &#123;
        plane.life -= PLANE_LIFE / 2;//飞船掉一半的最大生命值
        tmp-&gt;life = 0;//产生撞击的UFO死掉
    &#125;
&#125;
//飞机的撞击判断
void ufosCrashJudge()
&#123;
    ufoCrash(&amp;ufoa);
    ufoCrash(&amp;ufob);
    ufoCrash(&amp;ufoc);
&#125;

//显示分数
void showScore(int x,int y,int score)
&#123;
    
    TCHAR time_text[50];
    _stprintf_s(time_text, &quot;score:%d&quot;, score);
    settextstyle(40, 0, &quot;黑体&quot;); 
    outtextxy(x, y, time_text);
&#125;

//清空子弹
void clearBullet(list** pplist)
&#123;
    if (*pplist == NULL)
        return;
    list* cur = *pplist;//current指向第一个节点
    while (cur!=NULL)//遍历链表
    &#123;
        cur-&gt;isExist = 0;//所有子弹全部清楚
        cur = cur-&gt;pnext;//指向下一个节点
    &#125;
    listRemoveNode(pplist);//清0后移除
&#125;

//清理在场的所有子弹
void clearAllBullet()
&#123;
    clearBullet(&amp;plane_bullet_list);
    clearBullet(&amp;ufoa_bullet_list);
    clearBullet(&amp;ufob_bullet_list);
&#125;

//播放音乐函数
void playBgmMusic()
&#123;
    mciSendString(&quot;close bgm&quot;, NULL, 0, NULL);//以前可能播放了，每次都要先关闭
    mciSendString(&quot;open res\\bgm.mp3 alias bgm&quot;, NULL, 0, NULL);// alias gai
    mciSendString(&quot;play bgm repeat&quot;, NULL, 0, NULL);//循环播放
&#125;

void playBoomMusic()
&#123;
    mciSendString(_T(&quot;close boom&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom.mp3 alias boom&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom &quot;), NULL, 0, NULL);//单次播放
&#125;
void playBoom2Music()
&#123;
    mciSendString(_T(&quot;close boom2&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom2.mp3 alias boom2&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom2 &quot;), NULL, 0, NULL);//单次播放
&#125;
void playBoom3Music()
&#123;
    mciSendString(_T(&quot;close boom3&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom3.mp3 alias boom3&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom3 &quot;), NULL, 0, NULL);//单次播放
&#125;
void playShootMusic()
&#123;
    mciSendString(_T(&quot;close shoot&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\shoot.mp3 alias shoot&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play shoot&quot;), NULL, 0, NULL);//单次播放
&#125;

//在指定位置显示生命值
void showLife(int x, int y, int life)
&#123;
    TCHAR time_text[50];
    _stprintf_s(time_text, &quot;Life:%d&quot;, life);
    outtextxy(x, y, time_text);
&#125;

//结束界面
void showGameOver()
&#123;
    settextcolor(BGR(0xFFEC8B));
    settextstyle(80, 0, _T(&quot;微软雅黑&quot;));
    outtextxy(WIDTH / 2 - 160, 280, _T(&quot;GAME OVER&quot;));
    outtextxy(WIDTH / 2 - 160, 360, _T(&quot;按空格键继续&quot;));
    FlushBatchDraw();
    while (&#39; &#39; != _getch());//等待用户输入空格
    score = 0;//重置分数
    game_over = 0;//重置标记
    dataInit();//重置飞行器的属性
    clearAllBullet();//清除在场的子弹
    showBeginPicture();//返回开场界面重新开始
&#125;

//显示开场界面
void showBeginPicture()
&#123;
    playBgmMusic();

    drawAlpha(&amp;temp_img, 0, 0, &amp;img_bk);
    drawAlpha(&amp;temp_img, 220, 400, &amp;img_plane);
    drawAlpha(&amp;temp_img, 100, 100, &amp;img_ufoa);
    putimage(0, 0, &amp;temp_img);

    setbkmode(TRANSPARENT);// 字体透明
    settextcolor(BGR(0xFFEC8B));
    settextstyle(80, 0, _T(&quot;微软雅黑&quot;));
    outtextxy(WIDTH / 2 - 100, 100, _T(&quot;飞机大战&quot;));
    settextstyle(40, 0, _T(&quot;黑体&quot;));
    settextcolor(0xFFA500);
    outtextxy(WIDTH / 2 - 100, 280, _T(&quot;W、S、A、D 移动&quot;));
    outtextxy(WIDTH / 2 - 100, 340, _T(&quot;K 发射子弹&quot;));
    outtextxy(WIDTH / 2 - 100, 400, _T(&quot;按任意键继续&quot;));
    FlushBatchDraw();
    _getch();
&#125;

</code></pre>
<h4 id="2-引入头文件"><a href="#2-引入头文件" class="headerlink" title="2.引入头文件"></a>2.引入头文件</h4><pre><code class="c++">#include &lt;iostream&gt;
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;//用于键盘输入函数
#include&lt;time.h&gt;
#include&lt;math.h&gt;//引用数学函数
</code></pre>
<h4 id="3-定义游戏画面尺寸，搭建窗口"><a href="#3-定义游戏画面尺寸，搭建窗口" class="headerlink" title="3.定义游戏画面尺寸，搭建窗口"></a>3.定义游戏画面尺寸，搭建窗口</h4><pre><code class="c++">//游戏画面尺寸
#define HEIGHT 720
#define WIDTH 1280
#define PI 3.1415926 //圆周率
</code></pre>
<pre><code class="c++"> initgraph(WIDTH, HEIGHT);//创建绘图窗口
</code></pre>
<h4 id="4-定义图像，载入资源"><a href="#4-定义图像，载入资源" class="headerlink" title="4.定义图像，载入资源"></a>4.定义图像，载入资源</h4><pre><code class="c++">//载入资源前，需定义图像变量
IMAGE img_bk, img_plane, temp_img,
img_ufoa, img_ufob, img_ufoc,//敌机
img_plane_bullet, img_ufoa_bullet, img_ufob_bullet;//子弹
</code></pre>
<pre><code class="c++">//载入资源
void loadRes()
&#123;
    loadimage(&amp;img_bk, &quot;res\\background.png&quot;);//从文件中读取图像
    loadimage(&amp;temp_img, &quot;res\\background.png&quot;);//绝对路径
    loadimage(&amp;img_plane, &quot;res\\plane.png&quot;);
    loadimage(&amp;img_ufoa, &quot;res\\ufoa.png&quot;);
    loadimage(&amp;img_ufob, &quot;res\\ufob.png&quot;);
    loadimage(&amp;img_ufoc, &quot;res\\ufoc.png&quot;);
    loadimage(&amp;img_plane_bullet, &quot;res\\plane_bullet.png&quot;);
    loadimage(&amp;img_ufoa_bullet, &quot;res\\ufoa_bullet.png&quot;);
    loadimage(&amp;img_ufob_bullet, &quot;res\\ufob_bullet.png&quot;);
&#125;
</code></pre>
<h4 id="5-定义全局变量和结构体"><a href="#5-定义全局变量和结构体" class="headerlink" title="5.定义全局变量和结构体"></a>5.定义全局变量和结构体</h4><pre><code class="c++">//生命值
int PLANE_LIFE = 100;
int UFOA_LIFE = 1500;
int UFOB_LIFE = 150;
int UFOC_LIFE = 100;
</code></pre>
<pre><code class="c++">int score = 0;//得分
int game_over = 0;//等于0游戏不结束
</code></pre>
<pre><code class="c++">//定义飞机结构体
struct aircraft
&#123;
    int x, y;//坐标
    int width;
    int height;
    int speed;//速度
    int life;//生命值
    int new_born_flg;//是否重生

&#125;;

//定义飞行器
aircraft plane, ufoa, ufob, ufoc;

//用于判断子弹碰撞飞机的区域

//向量的结构体
struct vector
&#123;
    float x, y;
&#125;;

//三角形的结构体
struct triangle
&#123;
    float ax, ay, bx, by, cx, cy;
&#125;;
</code></pre>
<pre><code class="c++">//子弹结构体
typedef struct bullet
&#123;
    float x, y;//cpu算浮点型，速度有点慢，整型会好点
    float vx, vy;//水平和竖直方向
    int damage;//伤害
    int isExist;//判断子弹是否需要删除
    bullet* pnext;//指向下一个子弹节点的指针
&#125;list;//取一个别名list

list* plane_bullet_list = NULL; // 飞机子弹列表的头节点
list* ufoa_bullet_list = NULL;  //UFOA的子弹列表的开头
list* ufob_bullet_list = NULL;  //UFOB的子弹列表的开头
</code></pre>
<h4 id="6-初始化所有飞行器数据"><a href="#6-初始化所有飞行器数据" class="headerlink" title="6.初始化所有飞行器数据"></a>6.初始化所有飞行器数据</h4><p>写宽高时，可以参考原图片的像素宽高</p>
<pre><code class="c++">//飞行器数据的初始化
void dataInit()
&#123;
    //坐标
    plane.x = WIDTH/2;
    plane.y = HEIGHT-200;
    plane.width = 80;
    plane.height = 80;
    plane.speed = 10;
    plane.new_born_flg = 1;

    ufoa = &#123; 0,0 &#125;;//书写的第二种形式
    ufoa.width = 300;
    ufoa.height = 150;
    ufoa.speed = 3;
    ufoa.new_born_flg = 1;

    ufob = &#123; 300,0 &#125;;
    ufob.width = 150;
    ufob.height = 50;
    ufob.speed = 8;
    ufob.new_born_flg = 1;

    ufoc = &#123; 450,200&#125;;
    ufoc.width = 100;
    ufoc.height = 60;
    ufoc.speed = 15;
    ufoc.new_born_flg = 1;

    //生命值
    plane.life = PLANE_LIFE;
    ufoa.life = UFOA_LIFE;
    ufob.life = UFOB_LIFE;
    ufoc.life = UFOC_LIFE;
&#125;
</code></pre>
<h4 id="7-绘制游戏开始页面"><a href="#7-绘制游戏开始页面" class="headerlink" title="7.绘制游戏开始页面"></a>7.绘制游戏开始页面</h4><pre><code class="c++">//显示开场界面
void showBeginPicture()
&#123;
    playBgmMusic();//引入背景音乐

    drawAlpha(&amp;temp_img, 0, 0, &amp;img_bk);//背景图
    drawAlpha(&amp;temp_img, 220, 400, &amp;img_plane);//飞机
    drawAlpha(&amp;temp_img, 100, 100, &amp;img_ufoa);//敌机
    putimage(0, 0, &amp;temp_img);//绘制图像
    //显示字体
    setbkmode(TRANSPARENT);// 字体透明
    settextcolor(BGR(0xFFEC8B));//文本颜色
    settextstyle(80, 0, _T(&quot;微软雅黑&quot;));//高度，0表示宽度自适应
    outtextxy(WIDTH / 2 - 100, 100, _T(&quot;飞机大战&quot;));//显示坐标，显示的字
    settextstyle(40, 0, _T(&quot;黑体&quot;));
    settextcolor(0xFFA500);
    outtextxy(WIDTH / 2 - 100, 280, _T(&quot;W、S、A、D 移动&quot;));
    outtextxy(WIDTH / 2 - 100, 340, _T(&quot;K 发射子弹&quot;));
    outtextxy(WIDTH / 2 - 100, 400, _T(&quot;按任意键继续&quot;));
    FlushBatchDraw();//结束绘画
    _getch();
&#125;
</code></pre>
<h5 id="引入背景音乐和特效音乐"><a href="#引入背景音乐和特效音乐" class="headerlink" title="引入背景音乐和特效音乐"></a>引入背景音乐和特效音乐</h5><p>首先加载静态库</p>
<pre><code class="c++">//引用 Windows Multimedia API
#pragma comment(lib,&quot;winmm.lib&quot;)
</code></pre>
<pre><code class="c++">//播放音乐函数
void playBgmMusic()
&#123;
    mciSendString(&quot;close bgm&quot;, NULL, 0, NULL);//以前可能播放了，每次都要先关闭
    mciSendString(&quot;open res\\bgm.mp3 alias bgm&quot;, NULL, 0, NULL);
    mciSendString(&quot;play bgm repeat&quot;, NULL, 0, NULL);//循环播放
&#125;
void playBoomMusic()//ufoa死亡音效
&#123;
    mciSendString(_T(&quot;close boom&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom.mp3 alias boom&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom &quot;), NULL, 0, NULL);//单次播放
&#125;
void playBoom2Music()//ufob死亡音效
&#123;
    mciSendString(_T(&quot;close boom2&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom2.mp3 alias boom2&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom2 &quot;), NULL, 0, NULL);//单次播放
&#125;
void playBoom3Music()//ufoc死亡音效
&#123;
    mciSendString(_T(&quot;close boom3&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\boom3.mp3 alias boom3&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play boom3 &quot;), NULL, 0, NULL);//单次播放
&#125;
void playShootMusic()//射击音效
&#123;
    mciSendString(_T(&quot;close shoot&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;open res\\shoot.mp3 alias shoot&quot;), NULL, 0, NULL);
    mciSendString(_T(&quot;play shoot&quot;), NULL, 0, NULL);//单次播放
&#125;
</code></pre>
<h5 id="drawAlpha函数"><a href="#drawAlpha函数" class="headerlink" title="drawAlpha函数"></a>drawAlpha函数</h5><p>该函数解决方框黑底问题，实现透明</p>
<pre><code class="c++">// 根据透明度绘图(透明贴图显示)
void drawAlpha(IMAGE* dstimg, int x, int y, IMAGE* srcimg)
&#123;
    // 变量初始化
    DWORD* dst = GetImageBuffer(dstimg);
    DWORD* src = GetImageBuffer(srcimg);
    int src_width = srcimg-&gt;getwidth();
    int src_height = srcimg-&gt;getheight();
    int dst_width = (dstimg == NULL ? getwidth() : dstimg-&gt;getwidth());
    int dst_height = (dstimg == NULL ? getheight() : dstimg-&gt;getheight());

    // 计算贴图的实际长宽
    int iwidth = (x + src_width &gt; dst_width) ? dst_width - x : src_width;		// 处理超出右边界
    int iheight = (y + src_height &gt; dst_height) ? dst_height - y : src_height;	// 处理超出下边界
    if (x &lt; 0) &#123; src += -x;				iwidth -= -x;	x = 0; &#125;				// 处理超出左边界
    if (y &lt; 0) &#123; src += src_width * -y;	iheight -= -y;	y = 0; &#125;				// 处理超出上边界

    // 修正贴图起始位置
    dst += dst_width * y + x;
    // 实现透明贴图
    for (int iy = 0; iy &lt; iheight; ++iy)
    &#123;
        for (int i = 0; i &lt; iwidth; ++i)
        &#123;
            int sa = ((src[i] &amp; 0xff000000) &gt;&gt; 24);//获取阿尔法值
            if (sa != 0)//假如是完全透明就不处理
                if (sa == 255)//假如完全不透明则直接拷贝
                    dst[i] = src[i];
                else//真正需要阿尔法混合计算的图像边界才进行混合
                    dst[i] = ((((src[i] &amp; 0xff0000) &gt;&gt; 16) + ((dst[i] &amp; 0xff0000) &gt;&gt; 16) * (255 - sa) / 255) &lt;&lt; 16) | ((((src[i] &amp; 0xff00) &gt;&gt; 8) + ((dst[i] &amp; 0xff00) &gt;&gt; 8) * (255 - sa) / 255) &lt;&lt; 8) | ((src[i] &amp; 0xff) + (dst[i] &amp; 0xff) * (255 - sa) / 255);
        &#125;
        dst += dst_width;
        src += src_width;
    &#125;
&#125;
</code></pre>
<h5 id="解决画面闪烁"><a href="#解决画面闪烁" class="headerlink" title="解决画面闪烁"></a>解决画面闪烁</h5><pre><code>//解决画面闪烁
BeginBatchDraw();//开始批量绘图
FlushBatchDraw();//执行此语句才绘画出
EndBatchDraw();//结束绘画
</code></pre>
<h4 id="8-敌机运动与子弹发射"><a href="#8-敌机运动与子弹发射" class="headerlink" title="8.敌机运动与子弹发射"></a>8.敌机运动与子弹发射</h4><h5 id="随机函数rand"><a href="#随机函数rand" class="headerlink" title="随机函数rand()"></a>随机函数rand()</h5><p>使用该函数前，需确定种子，以时间来随机变动</p>
<pre><code class="c++">srand(time(NULL));//随机数种子
</code></pre>
<h5 id="链表发射子弹"><a href="#链表发射子弹" class="headerlink" title="链表发射子弹"></a>链表发射子弹</h5><pre><code class="c++">/*&amp;list 传链表地址才能改变链表
链表list又由头结点地址决定
所以用二级指针传地址*/
//在某链表尾部插入一个数据
void listPushBack(list** pplist, list* newNode)//** pplist 指向地址的指针
&#123;
    if (*pplist == NULL)//如果链表为空，那么新增的节点就是第一个
    &#123;
        *pplist = newNode;
        return;
    &#125;
    list* cur = *pplist;//指向头结点
    while (cur-&gt;pnext != NULL)//找到最后一个节点
    &#123;
        cur = cur-&gt;pnext;
    &#125;
    cur-&gt;pnext = newNode;//插入新的节点
&#125;

//飞机发射的子弹，增加一个节点
list* creatPlaneBullet(float vx,float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针用箭头-&gt;
    //结构体用点
    p-&gt;x= plane.x + plane.width / 2+10;//依据飞机位置写子弹位置
    p-&gt;y = plane.y;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 50;
    return p;

&#125;
</code></pre>
<h5 id="ufoa"><a href="#ufoa" class="headerlink" title="ufoa"></a>ufoa</h5><pre><code class="c++">//大UFO缓慢向前移动，到达一定的位置回去
void ufoaMove()
&#123;
    static int dir = 1;//1表示前进
    static int cnt = 0;//计数器
    int ufoa_reload_cnt = 80;//发射子弹的计数器，数值越小发射子弹越快
    int ufoa_fire_num = 20;  //UFOA共发射多少路子弹
    if (1 == ufoa.new_born_flg)//新出生的ufoa，重置x,y的坐标
    &#123;
        ufoa.new_born_flg = 0;
        ufoa.x = rand() % (WIDTH - ufoa.width);//确保在屏幕内
        ufoa.y = -50;//从最上方出生
    &#125;
    if (ufoa.y &gt; 200)
    &#123;
        dir = 0;//0表示后退
    &#125;
    else if (ufoa.y &lt; -150)
    &#123;
        dir = 1;
        ufoa.new_born_flg = 1;//重生
    &#125;
    if (1 == dir)
    &#123;
        ufoa.y += ufoa.speed;//前进
    &#125;
    else
    &#123;
        ufoa.y -= ufoa.speed;//后退
    &#125;

    //cnt到达指定的间隔以后，转圈发射子弹
    if (++cnt % ufoa_reload_cnt == 0)
    &#123;
        //一圆圈20子弹
        for (int i = 0; i &lt; ufoa_fire_num; i++)
        &#123;
            //使子弹呈圆形散发
            float angle = i * 2 * PI / ufoa_fire_num;
            float vx = 4 * sin(angle);
            float vy = 4 * cos(angle);
            listPushBack(&amp;ufoa_bullet_list, creatUFOA_Bullet(vx, vy));//装子弹后发射
        &#125;
        
    &#125;
    if (cnt &gt; 99999)//避免溢出
        cnt = 0;


&#125;
</code></pre>
<pre><code class="c++">//ufoa发射的子弹，增加一个节点
list* creatUFOA_Bullet(float vx, float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针引用结构体成员用箭头-&gt;
    //结构体引用成员用点
    p-&gt;x = ufoa.x + ufoa.width / 2 ;
    p-&gt;y = ufoa.y;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 10;
    return p;

&#125;
</code></pre>
<h5 id="ufob"><a href="#ufob" class="headerlink" title="ufob"></a>ufob</h5><pre><code class="c++">//UFOB左右快速移动，慢速向下移动
void ufobMove()
&#123;
    static int step = ufob.speed;//spep表示方向与速度
    static int cnt = 0;
    int ufob_reload_cnt = 60;//UFOb  发射子弹的计数器，数值越小发射子弹越快
    if (1 == ufob.new_born_flg)//新出生的ufob ，重置x,y的坐标
    &#123;
        ufob.new_born_flg = 0;
        ufob.x = rand() % (WIDTH - ufob.width);
        ufob.y = -ufob.height;
    &#125;
    //水平撞墙返回
    if ((ufob.x &lt;= 0) || (ufob.x + ufob.width &gt;= WIDTH))
        step = -step;
    ufob.x += step;
    ufob.y++;
    //超出下边界，重生，y坐标重置，x坐标随机
    if (ufob.y &gt;= HEIGHT)
        ufob.new_born_flg = 1;
    //竖直向下发射子弹
    if (++cnt % ufob_reload_cnt == 0)
    &#123;
        listPushBack(&amp;ufob_bullet_list, creatUFOB_Bullet(0, 5));
    &#125;
    if (cnt &gt; 999999) cnt = 0;//当计数器超过999999 进行清零
&#125;
</code></pre>
<pre><code class="c++">//ufob发射的子弹，增加一个节点
list* creatUFOB_Bullet(float vx, float vy)
&#123;
    list* p = (list*)malloc(sizeof(list));//赋空间
    //结构体指针用箭头-&gt;
    //结构体用点
    p-&gt;x = ufob.x + ufob.width / 2-10;
    p-&gt;y = ufob.y+30;
    p-&gt;vx = vx;
    p-&gt;vy = vy;
    p-&gt;isExist = 1;
    p-&gt;pnext = NULL;
    p-&gt;damage = 20;
    return p;

&#125;
</code></pre>
<h5 id="ufoc"><a href="#ufoc" class="headerlink" title="ufoc"></a>ufoc</h5><pre><code class="c++">//ufoc撞向飞机
void ufocMove()
&#123;
    //显卡擅长做浮点型运算
    static float dist_x = 0, dist_y = 0;//ufoc出生时，记录与飞机的横竖距离
    static float tmp_x = 0, tmp_y = 0;//储存x,y坐标的临时变量，浮点型方便计算
    static float vx = 0, vy = 0;//水平和竖直方向的速度
    float step = 1000 / ufoc.speed;//调整UFO速度
    if (1 == ufoc.new_born_flg)
    &#123;
        ufoc.new_born_flg = 0;
        tmp_x = rand() % (WIDTH - ufoc.width);//敌机的坐标再左上角
        tmp_y = -ufoc.height;
        dist_x = plane.x - tmp_x;//计算飞机与ufoc的距离
        dist_y = plane.y - tmp_y;
        vx = dist_x / step;
        vy = dist_y / step;
    &#125;
    tmp_x += vx;
    tmp_y += vy;
    ufoc.x = (int)(tmp_x + 0.5);//加0.5相当于四舍五入
    ufoc.y = (int)(tmp_y + 0.5);
    //边界判断，可以超出画面，但不超出太多
    if (ufoc.x &lt; -ufoc.width)
        ufoc.new_born_flg = 1;
    else if (ufoc.x &gt; WIDTH + ufoc.width)
        ufoc.new_born_flg = 1;
    //超出下边界，重生，y坐标重置，x坐标随机
    if (ufoc.y &gt;= HEIGHT)
        ufoc.new_born_flg = 1;

&#125;
</code></pre>
<h4 id="9-通过键盘控制飞机"><a href="#9-通过键盘控制飞机" class="headerlink" title="9.通过键盘控制飞机"></a>9.通过键盘控制飞机</h4><h5 id="按键输入的枚举列表"><a href="#按键输入的枚举列表" class="headerlink" title="按键输入的枚举列表"></a>按键输入的枚举列表</h5><pre><code class="c++">//按键输入的枚举列表
enum GAMEINPUT
&#123;
    //用0x十六进制表示
    NOINPUT=0X0,
    UPINPUT=0X1,
    DOWNINPUT=0X2,
    LEFTINPUT=0X4,
    RIGHTINPUT=0X8,
    FIREINPUT=0X10
&#125;;
int input = NOINPUT;//判断输入变量
//一个变量储存多个状态（重点）
</code></pre>
<h5 id="飞机移动"><a href="#飞机移动" class="headerlink" title="飞机移动"></a>飞机移动</h5><pre><code class="c++">//同时获取多个输入，操作飞机
void getInput()
&#123;
    int reload_time = 100;//装填时间，100ms 即每一百毫秒才能射击一次子弹
    static int fire_start = 0;//静态变量，储存开火的时间
    int tmp = clock();//当前时间

    //判断获取键值且最高为1
    if (GetAsyncKeyState(&#39;W&#39;) &amp; 0x8000)
    &#123;
        input |= UPINPUT;// 等价 input =input|UPINPUT  |是按位或操作，就是只要有一个1就是1，两个都是0才是0
    &#125;
    if (GetAsyncKeyState(&#39;S&#39;) &amp; 0x8000)
    &#123;
        input |= DOWNINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;A&#39;) &amp; 0x8000)
    &#123;
        input |= LEFTINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;D&#39;) &amp; 0x8000)
    &#123;
        input |= RIGHTINPUT;
    &#125;
    if (GetAsyncKeyState(&#39;K&#39;) &amp; 0x8000)
    &#123;
        if (tmp - fire_start &gt;= reload_time)//每100ms发射一次
        &#123;
            input |= FIREINPUT;
            fire_start = tmp;
        &#125;
            
    &#125;
&#125;

void dealInput()
&#123;
    if ((input &amp; UPINPUT)&amp;&amp;(plane.y&gt;=0))//加限制，不出边界
    &#123;
        plane.y -= plane.speed;
    &#125;
    if ((input &amp; LEFTINPUT)&amp;&amp; (plane.x &gt;= 0))
    &#123;
        plane.x -= plane.speed;
    &#125;
    if ((input &amp; DOWNINPUT)&amp;&amp;(plane.y &lt;=HEIGHT-120))
    &#123;
        plane.y += plane.speed;
    &#125;
    if ((input &amp; RIGHTINPUT )&amp;&amp; (plane.x &lt;=WIDTH-120))
    &#123;
        plane.x += plane.speed;
    &#125;
    if (input &amp; FIREINPUT)
    &#123;
        playShootMusic();
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(0, -20));//往y负方向走
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(-10, -17.32));//30° 散弹左 20*cos30°约等于17.32
        listPushBack(&amp;plane_bullet_list, creatPlaneBullet(10, -17.32));//散弹右
        /*mybullet_buf[mybullet_idx].x = plane.x + plane.width / 2;
        mybullet_buf[mybullet_idx].y = plane.y;
        mybullet_buf[mybullet_idx].vx = 0;
        mybullet_buf[mybullet_idx].vy = -20;//子弹坐标在减少
        mybullet_idx++;*/
        
    &#125;
    input = NOINPUT;//清零
&#125;

</code></pre>
<h5 id="飞机射击"><a href="#飞机射击" class="headerlink" title="飞机射击"></a>飞机射击</h5><pre><code class="c++">//判断飞机的子弹是否击中UFO，执行相应的加分与减命的操作
void bulletHitUFO(aircraft* tmp)
&#123;
    for (list* cur = plane_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        //子弹在UFO的矩形图片内时，认为击中
        if ((cur-&gt;x &gt; tmp-&gt;x) &amp;&amp; (cur-&gt;x &lt; tmp-&gt;x + tmp-&gt;width))
        &#123;
            if ((cur-&gt;y &gt; tmp-&gt;y) &amp;&amp; (cur-&gt;y &lt; tmp-&gt;y + tmp-&gt;height))
            &#123;
                tmp-&gt;life -= cur-&gt;damage;//飞行器生命值 - 子弹的伤害
                cur-&gt;isExist = 0;  //清除子弹的存在标记
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="10-绘制游戏元素"><a href="#10-绘制游戏元素" class="headerlink" title="10.绘制游戏元素"></a>10.绘制游戏元素</h4><h5 id="显示飞机与敌机"><a href="#显示飞机与敌机" class="headerlink" title="显示飞机与敌机"></a>显示飞机与敌机</h5><pre><code class="c++">//绘制所有的飞机
void showAircraft()
&#123;
    drawAlpha(&amp;temp_img, 0, 0, &amp;img_bk);
    drawAlpha(&amp;temp_img, plane.x, plane.y, &amp;img_plane);
    drawAlpha(&amp;temp_img, ufoa.x, ufoa.y, &amp;img_ufoa);
    drawAlpha(&amp;temp_img, ufob.x, ufob.y, &amp;img_ufob);
    drawAlpha(&amp;temp_img, ufoc.x, ufoc.y, &amp;img_ufoc);

&#125;
</code></pre>
<h5 id="显示子弹"><a href="#显示子弹" class="headerlink" title="显示子弹"></a>显示子弹</h5><pre><code class="c++">//改变飞机子弹坐标
void listChangeXY(list** pplist)
&#123;
    if (*pplist == NULL)
        return;
    list* cur = *pplist;//current指向第一个节点
    while (cur != NULL)//遍历链表
    &#123;
        cur-&gt;x += cur-&gt;vx;
        cur-&gt;y += cur-&gt;vy;
        //判断子弹是否离开视野
        if ((cur-&gt;y &lt; -20) || (cur-&gt;y &gt; HEIGHT) || (cur-&gt;x &gt; WIDTH) || (cur-&gt;x &lt; 0))
            cur-&gt;isExist = 0;
        cur = cur-&gt;pnext;//指向下一节点
    &#125;

&#125;

//删除链表中isExist为0的节点
void listRemoveNode(list** pplist)
&#123;
    if (*pplist == NULL)//如果链表为空，就没有可删除的节点了
        return;
    list* cur = *pplist;//current先指向第一个节点
    list* prev = NULL;  //previous指向上一个节点的指针
    while (cur != NULL)//遍历链表
    &#123;
        if (cur-&gt;isExist == 0)//判断节点是否需要删除
        &#123;
            if (*pplist == cur)//如果删除的是第一个节点
            &#123;
                *pplist = cur-&gt;pnext;  //更改链表的地址，让下一个节点作为头结点 ，如果没有节点，则链表为空
                free(cur);             //释放当前节点（第一个节点的）空间
                cur = *pplist;         //让cur指向下一个节点
            &#125;
            else
            &#123;
                prev-&gt;pnext = cur-&gt;pnext;  //记录下一个节点的地址
                free(cur);                 //释放当前节点空间
                cur = prev;                //当前节点变成前一个节点
            &#125;
        &#125;
        else //如果不需要删除节点，储存当前节点为前一个节点，然后指向下一个节点
        &#123;
            prev = cur;
            cur = cur-&gt;pnext;
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="c++">//绘制发出来的子弹
void showBullet()
&#123;
    //飞机发射的子弹
    listChangeXY(&amp;plane_bullet_list);//计算子弹新的位置
    bulletHitUFO(&amp;ufoc);//判断子弹是否击中，更改生命和子弹状态
    bulletHitUFO(&amp;ufoa);
    bulletHitUFO(&amp;ufob);
    listRemoveNode(&amp;plane_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = plane_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x, cur-&gt;y, &amp;img_plane_bullet);
    &#125;

    //ufoa发出的子弹
    listChangeXY(&amp;ufoa_bullet_list);//计算子弹新的位置
    listRemoveNode(&amp;ufoa_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = ufoa_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x - 10, cur-&gt;y - 10, &amp;img_ufoa_bullet);
    &#125;

    //ufob发出的子弹
    listChangeXY(&amp;ufob_bullet_list);//计算子弹新的位置
    listRemoveNode(&amp;ufob_bullet_list);//超出视野或者击中飞行器的子弹删除掉
    for (list* cur = ufob_bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        drawAlpha(&amp;temp_img, cur-&gt;x - 15, cur-&gt;y - 30, &amp;img_ufob_bullet);
    &#125;

    //判断敌机子弹是否击中，更改飞机生命和子弹状态
    bulletHitPlane(ufoa_bullet_list);
    bulletHitPlane(ufob_bullet_list);
&#125;

</code></pre>
<h4 id="11-判断飞机器生命状态和统计分数"><a href="#11-判断飞机器生命状态和统计分数" class="headerlink" title="11.判断飞机器生命状态和统计分数"></a>11.判断飞机器生命状态和统计分数</h4><pre><code class="c++">//飞行器生存判断
void aircraftLifeJudge()
&#123;
    if (ufoa.life &lt;= 0)
    &#123;
        //aircraftReborn(&amp;ufoa, ufoa.life);//这是错误写法
        playBoomMusic();
        aircraftReborn(&amp;ufoa, UFOA_LIFE);
        score += UFOA_LIFE;
    &#125;
    if (ufob.life &lt;= 0)
    &#123;
        playBoom2Music();
        aircraftReborn(&amp;ufob, UFOB_LIFE);
        score += UFOB_LIFE;
    &#125;
    if (ufoc.life &lt;= 0)
    &#123;
        playBoom3Music();
        aircraftReborn(&amp;ufoc, UFOC_LIFE);
        score += UFOC_LIFE;
    &#125;
    if (plane.life &lt;= 0)
    &#123;
        game_over = 1;
    &#125;

&#125;
</code></pre>
<pre><code class="c++">//飞行器重生 参数为飞行器的地址，以及重生的血量
void aircraftReborn(aircraft* tmp, int life)
&#123;
    tmp-&gt;new_born_flg = 1;
    tmp-&gt;life = life;
&#125;
</code></pre>
<h4 id="12-细化碰撞判断"><a href="#12-细化碰撞判断" class="headerlink" title="12.细化碰撞判断"></a>12.细化碰撞判断</h4><pre><code class="c++">//向量的结构体
struct vector
&#123;
    float x, y;
&#125;;

//三角形的结构体
struct triangle
&#123;
    float ax, ay, bx, by, cx, cy;
&#125;;
</code></pre>
<pre><code class="c++">//传入2组坐标，生成向量
vector getVector(float x1, float y1, float x2, float y2)
&#123;
    vector tmp;
    tmp.x = x2 - x1;
    tmp.y = y2 - y1;
    return tmp;
&#125;

//2个向量的叉乘，结果仍然是向量，正负可以表示方向
float crossProduct(vector a, vector b)
&#123;
    float tmp = a.x * b.y - a.y * b.x;
    return tmp;
&#125;

//判断点(x,y)是否在三角形内
int isPointInTriangle(triangle tri, float x, float y)
&#123;
    vector pa = getVector(tri.ax, tri.ay, x, y);//向量pa，是a-p
    vector pb = getVector(tri.bx, tri.by, x, y);//向量pb，是b-p
    vector pc = getVector(tri.cx, tri.cy, x, y);//向量pc，是c-p
    float t1 = crossProduct(pa, pb);
    float t2 = crossProduct(pb, pc);
    float t3 = crossProduct(pc, pa);
    return t1 * t2 &gt;= 0 &amp;&amp; t1 * t3 &gt;= 0 &amp;&amp; t2 * t3 &gt;= 0;
&#125;

//根据飞机图片的x 与 y坐标 来构建一个三角形，用于碰撞判断
triangle getPlaneTriangle()
&#123;
    triangle tmp;
    //a 是最上边的点，b 是右下， c是左下。
    tmp.ax = plane.x + plane.width / 2;
    tmp.ay = plane.y;
    tmp.bx = plane.x + plane.width;
    tmp.by = plane.y + plane.height;
    tmp.cx = plane.x;
    tmp.cy = plane.y + plane.height;
    return tmp;
&#125;

//判断UFO的子弹是否击中飞机，执行相应的加分与减命的操作,参数是UFO的子弹链表
void bulletHitPlane(list* bullet_list)
&#123;
    for (list* cur = bullet_list; cur != NULL; cur = cur-&gt;pnext)
    &#123;
        //子弹在飞机的矩形图片内时，再判断是否在飞机的三角形内，减少计算量
        if ((cur-&gt;x &gt; plane.x) &amp;&amp; (cur-&gt;x &lt; plane.x + plane.width))
        &#123;
            if ((cur-&gt;y &gt; plane.y) &amp;&amp; (cur-&gt;y &lt; plane.y + plane.height))
            &#123;
                triangle tri = getPlaneTriangle();//获取飞机的三角形参数
                if (isPointInTriangle(tri, cur-&gt;x, cur-&gt;y))//子弹与飞机相撞
                &#123;
                    plane.life -= cur-&gt;damage;
                    cur-&gt;isExist = 0;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

//UFO是否与飞机碰撞  判断UFO下方中间的点,中间偏左与中间偏右的点，是否处于飞行器的范围内
void ufoCrash(aircraft* tmp)
&#123;
    triangle tri = getPlaneTriangle();//获取飞机的三角形参数
    if (isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width / 2, tmp-&gt;y + tmp-&gt;height)
        || isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width / 4, tmp-&gt;y + tmp-&gt;height / 2)
        || isPointInTriangle(tri, tmp-&gt;x + tmp-&gt;width - tmp-&gt;width / 4, tmp-&gt;y + tmp-&gt;height / 2))
    &#123;
        plane.life -= PLANE_LIFE / 2;//飞船掉一半的最大生命值
        tmp-&gt;life = 0;//产生撞击的UFO死掉
    &#125;
&#125;
//飞机的撞击判断
void ufosCrashJudge()
&#123;
    ufoCrash(&amp;ufoa);
    ufoCrash(&amp;ufob);
    ufoCrash(&amp;ufoc);
&#125;
</code></pre>
<h4 id="13-实时更新显示分数和生命值"><a href="#13-实时更新显示分数和生命值" class="headerlink" title="13.实时更新显示分数和生命值"></a>13.实时更新显示分数和生命值</h4><pre><code class="c++">//显示分数
void showScore(int x,int y,int score)
&#123;
    
    TCHAR time_text[50];
    _stprintf_s(time_text, &quot;score:%d&quot;, score);
    settextstyle(40, 0, &quot;黑体&quot;); 
    outtextxy(x, y, time_text);
&#125;
</code></pre>
<pre><code class="c++">//在指定位置显示生命值
void showLife(int x, int y, int life)
&#123;
    TCHAR time_text[50];
    _stprintf_s(time_text, &quot;Life:%d&quot;, life);
    outtextxy(x, y, time_text);
&#125;
</code></pre>
<h4 id="14-结束时清空操作"><a href="#14-结束时清空操作" class="headerlink" title="14.结束时清空操作"></a>14.结束时清空操作</h4><pre><code class="c++">//清空子弹
void clearBullet(list** pplist)
&#123;
    if (*pplist == NULL)
        return;
    list* cur = *pplist;//current指向第一个节点
    while (cur!=NULL)//遍历链表
    &#123;
        cur-&gt;isExist = 0;//所有子弹全部清楚
        cur = cur-&gt;pnext;//指向下一个节点
    &#125;
    listRemoveNode(pplist);//清0后移除
&#125;

//清理在场的所有子弹
void clearAllBullet()
&#123;
    clearBullet(&amp;plane_bullet_list);
    clearBullet(&amp;ufoa_bullet_list);
    clearBullet(&amp;ufob_bullet_list);
&#125;
</code></pre>
<h4 id="15-结束界面"><a href="#15-结束界面" class="headerlink" title="15.结束界面"></a>15.结束界面</h4><pre><code class="c++">//结束界面
void showGameOver()
&#123;
    settextcolor(BGR(0xFFEC8B));
    settextstyle(80, 0, _T(&quot;微软雅黑&quot;));
    outtextxy(WIDTH / 2 - 160, 280, _T(&quot;GAME OVER&quot;));
    outtextxy(WIDTH / 2 - 160, 360, _T(&quot;按空格键继续&quot;));
    FlushBatchDraw();
    while (&#39; &#39; != _getch());//等待用户输入空格
    score = 0;//重置分数
    game_over = 0;//重置标记
    dataInit();//重置飞行器的属性
    clearAllBullet();//清除在场的子弹
    showBeginPicture();//返回开场界面重新开始
&#125;

</code></pre>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：飞机大战开发日志</li>
        <li>Post author：LiXiJian</li>
        <li>Create time：2023-01-17 15:32:26</li>
        <li>
            Post link：https://redefine.evanluo.top/2023/01/17/飞机大战开发日志/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/01/17/%E5%A4%A9%E5%A4%A9%E9%85%B7%E8%B7%91%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">天天酷跑开发日志</span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80-%E9%85%8D%E7%BD%AEeasyx"><span class="nav-text">一.配置easyx</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C-%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%A7%8B"><span class="nav-text">二.游戏项目开始</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E6%96%B0%E5%BB%BAc-%E6%96%87%E4%BB%B6"><span class="nav-text">1.创建空项目，然后新建c++文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BC%95%E5%85%A5%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-text">2.引入头文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9A%E4%B9%89%E6%B8%B8%E6%88%8F%E7%94%BB%E9%9D%A2%E5%B0%BA%E5%AF%B8%EF%BC%8C%E6%90%AD%E5%BB%BA%E7%AA%97%E5%8F%A3"><span class="nav-text">3.定义游戏画面尺寸，搭建窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AE%9A%E4%B9%89%E5%9B%BE%E5%83%8F%EF%BC%8C%E8%BD%BD%E5%85%A5%E8%B5%84%E6%BA%90"><span class="nav-text">4.定义图像，载入资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">5.定义全局变量和结构体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89%E9%A3%9E%E8%A1%8C%E5%99%A8%E6%95%B0%E6%8D%AE"><span class="nav-text">6.初始化所有飞行器数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E7%BB%98%E5%88%B6%E6%B8%B8%E6%88%8F%E5%BC%80%E5%A7%8B%E9%A1%B5%E9%9D%A2"><span class="nav-text">7.绘制游戏开始页面</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E5%92%8C%E7%89%B9%E6%95%88%E9%9F%B3%E4%B9%90"><span class="nav-text">引入背景音乐和特效音乐</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#drawAlpha%E5%87%BD%E6%95%B0"><span class="nav-text">drawAlpha函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E7%94%BB%E9%9D%A2%E9%97%AA%E7%83%81"><span class="nav-text">解决画面闪烁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%95%8C%E6%9C%BA%E8%BF%90%E5%8A%A8%E4%B8%8E%E5%AD%90%E5%BC%B9%E5%8F%91%E5%B0%84"><span class="nav-text">8.敌机运动与子弹发射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0rand"><span class="nav-text">随机函数rand()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%8F%91%E5%B0%84%E5%AD%90%E5%BC%B9"><span class="nav-text">链表发射子弹</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ufoa"><span class="nav-text">ufoa</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ufob"><span class="nav-text">ufob</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ufoc"><span class="nav-text">ufoc</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E9%80%9A%E8%BF%87%E9%94%AE%E7%9B%98%E6%8E%A7%E5%88%B6%E9%A3%9E%E6%9C%BA"><span class="nav-text">9.通过键盘控制飞机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E7%9A%84%E6%9E%9A%E4%B8%BE%E5%88%97%E8%A1%A8"><span class="nav-text">按键输入的枚举列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A3%9E%E6%9C%BA%E7%A7%BB%E5%8A%A8"><span class="nav-text">飞机移动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A3%9E%E6%9C%BA%E5%B0%84%E5%87%BB"><span class="nav-text">飞机射击</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E7%BB%98%E5%88%B6%E6%B8%B8%E6%88%8F%E5%85%83%E7%B4%A0"><span class="nav-text">10.绘制游戏元素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E9%A3%9E%E6%9C%BA%E4%B8%8E%E6%95%8C%E6%9C%BA"><span class="nav-text">显示飞机与敌机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%90%E5%BC%B9"><span class="nav-text">显示子弹</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-%E5%88%A4%E6%96%AD%E9%A3%9E%E6%9C%BA%E5%99%A8%E7%94%9F%E5%91%BD%E7%8A%B6%E6%80%81%E5%92%8C%E7%BB%9F%E8%AE%A1%E5%88%86%E6%95%B0"><span class="nav-text">11.判断飞机器生命状态和统计分数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-%E7%BB%86%E5%8C%96%E7%A2%B0%E6%92%9E%E5%88%A4%E6%96%AD"><span class="nav-text">12.细化碰撞判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E5%AE%9E%E6%97%B6%E6%9B%B4%E6%96%B0%E6%98%BE%E7%A4%BA%E5%88%86%E6%95%B0%E5%92%8C%E7%94%9F%E5%91%BD%E5%80%BC"><span class="nav-text">13.实时更新显示分数和生命值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E7%BB%93%E6%9D%9F%E6%97%B6%E6%B8%85%E7%A9%BA%E6%93%8D%E4%BD%9C"><span class="nav-text">14.结束时清空操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E7%BB%93%E6%9D%9F%E7%95%8C%E9%9D%A2"><span class="nav-text">15.结束界面</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">LiXiJian. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.4.4</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/12/31 16:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
