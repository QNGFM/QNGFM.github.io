<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="LiXiJian">
    
    <title>
        
        LiXiJian&#39;s Blog
    </title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://evan.beee.top" crossorigin>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/fontawesome.min.css">

    
<link rel="stylesheet" href="/css/brands.min.css">

    
<link rel="stylesheet" href="/css/solid.min.css">

    
<link rel="stylesheet" href="/css/regular.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/css2.css">

    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"LiXiJian's Blog"},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"0.4.4"};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">
    
    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LiXiJian&#39;s Blog
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <!-- Menu -->
                            <a class="" 
                                href="/" >
                                
                                    
                                        <i class="fa-regular fa-house"></i>
                                    
                                    HOME
                                
                            </a>
                            <!-- Submenu -->
                            
                        </li>
                    
                        <li class="menu-item">
                            <!-- Menu -->
                            <a class="" 
                                href="/archives" >
                                
                                    
                                        <i class="fa-regular fa-archive"></i>
                                    
                                    ARCHIVES
                                
                            </a>
                            <!-- Submenu -->
                            
                        </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class="" 
                       href="/" >
                         
                            
                                <i class="fa-regular fa-house"></i>
                            
                            HOME
                        
                    </a>
                </li>
                <!-- Submenu -->
                
            
                <li class="drawer-menu-item flex-center">
                    <a class="" 
                       href="/archives" >
                         
                            
                                <i class="fa-regular fa-archive"></i>
                            
                            ARCHIVES
                        
                    </a>
                </li>
                <!-- Submenu -->
                
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">
            <div class="article-title">
                <span class="title-hover-animation"><h1 style="font-size:2rem; font-weight: bold; margin: 10px 0;"></h1></span>
            </div>

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">LiXiJian</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-01-17 15:31:21</span>
        <span class="mobile">2023-01-17 15:31</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <hr>
<h2 id="title-天天酷跑开发日志"><a href="#title-天天酷跑开发日志" class="headerlink" title="title:天天酷跑开发日志"></a>title:天天酷跑开发日志</h2><h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1.创建项目"></a>1.创建项目</h2><p>选择空项目，再创建cpp源文件，导入tool.h头文件，tool.h源文件，这是两个工具包文件</p>
<p>先附上源码，再逐步分析</p>
<pre><code class="c++">#include&lt;graphics.h&gt;//easyx图形库
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;//键盘输入
#include&lt;vector&gt;//使用动态数组
#include&quot;tools.h&quot;

using namespace std;//声明命名空间


#define WIN_SCORE 10
#define WIN_WIDTH 1012
#define WIN_HEIGHT 396
#define OBSTACLE_COUNT 10
//背景图片
IMAGE imBgs[3];
int bgX[3];//背景图片的x坐标
int bgSpeed[3] = &#123; 1,2,4 &#125;;//各层背景移动速度

//人物图像定义
IMAGE imgHeros[12];
int heroX;//玩家的X坐标
int heroY;//玩家的Y坐标
int heroIndex;//玩家奔跑的帧序号

bool heroJump;//表示玩家正在跳跃

int jumpHeightMax;//人物跳跃的最大高度
int heroJumpOff;//偏移量
int update;//表示是否需要马上刷新画面

////定义小乌龟
//IMAGE imgTortoise;
//int torToiseX;//水平坐标
//int torToiseY;//垂直坐标
//bool torToiseExist;//当前窗口是否有小乌龟，确保窗口里只有一个小乌龟

int heroBlood;//英雄血量
int score;//得分

typedef enum &#123;
    TORTOISE,//乌龟 0
    LION,//狮子 1
    HOOK1,
    HOOK2,
    HOOK3,
    HOOK4,
    OBSTACLE_TYPE_COUNT//表示一共的个数（几种类型）
&#125; obstacle_type;

//IMAGE obstacleImgs[3][12];
//动态存储，避免浪费空间
vector&lt;vector&lt;IMAGE&gt;&gt;obstacleImgs;//存放所有障碍物的各个图片

typedef struct obstacle &#123;
    obstacle_type type;//障碍物的类型
    int imgIndex;//当前显示的图片的序号
    int x, y;//障碍物的坐标
    int speed;//速度
    int power;//杀伤力
    bool exist;//是否存在
    bool hited;//表示是否发生碰撞
    bool passed;//表示是否已经被通过
&#125;obstacle_t;

obstacle_t obstacles[OBSTACLE_COUNT];
int lastObsIndex;//记录上一个障碍物的序号，解决柱子和狮子同时出现的BUG

//定义下蹲帧图片
IMAGE imgHeroDown[2];
bool heroDown;//表示玩家是否处于下蹲状态

//定义数字资源
IMAGE imgSZ[10];

//游戏的初始化
void init()
&#123;
    //创建游戏窗口
    initgraph(WIN_WIDTH, WIN_HEIGHT);//EW_SHOWCONSOLE显示控制台

    //加载背景资源
    char name[64];
    for (int i = 0; i &lt; 3; i++)
    &#123;
        //&quot;res/bg001.png&quot; &quot;res/bg002.png&quot; &quot;res/bg003.png&quot;
        sprintf(name, &quot;res/bg%03d.png&quot;, i + 1);//sprintf函数：发送格式化输出到 string 所指向的字符串
        loadimage(&amp;imBgs[i], name);//读取资源
        bgX[i] = 0;//初始化X坐标
    &#125;

    //加载Hero奔跑的图片帧素材
    for (int i = 0; i &lt; 12; i++)
    &#123;
        //&quot;res/hero1.png&quot;...&quot;res/hero12.png&quot;
        sprintf(name, &quot;res/hero%d.png&quot;, i + 1);
        loadimage(&amp;imgHeros[i], name);
    &#125;

    //设置玩家的初始位置
    heroX = WIN_WIDTH * 0.5 - imgHeros[0].getwidth() * 0.5;
    heroY = 345 - imgHeros[0].getheight();
    heroIndex = 0;

    heroJump = false;//初始不跳
    jumpHeightMax = 345 - imgHeros[0].getheight() -110;
    heroJumpOff = -6;//每次向上眺4

    update = true;//开始刷新


    IMAGE imgTort;//定义小乌龟
    loadimage(&amp;imgTort, &quot;res/t1.png&quot;);
    vector&lt;IMAGE&gt; imgTortArray;
    imgTortArray.push_back(imgTort);//存进数组
    obstacleImgs.push_back(imgTortArray);//存进二维数组

    IMAGE imgLion;//定义小狮子
    vector&lt;IMAGE&gt; imgLionArray;
    for (int i = 0; i &lt; 6; i++) 
    &#123;
        sprintf(name, &quot;res/p%d.png&quot;, i + 1);
        loadimage(&amp;imgLion, name);
        imgLionArray.push_back(imgLion);//存进数组
    &#125;
    obstacleImgs.push_back(imgLionArray);//存进二维数组

    //初始化障碍池
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++)
    &#123;
        obstacles[i].exist = false;
    &#125;

    //加载下蹲素材
    loadimage(&amp;imgHeroDown[0], &quot;res/d1.png&quot;);
    loadimage(&amp;imgHeroDown[1], &quot;res/d2.png&quot;);
    heroDown = false;

    //加载柱子障碍物素材
    IMAGE imgH;
    for (int i = 0; i &lt; 4; i++) &#123;
        vector&lt;IMAGE&gt; imgHookArray;
        sprintf(name, &quot;res/h%d.png&quot;, i + 1);
        loadimage(&amp;imgH, name, 63, 260, true);//后面三个参数分别是width，height，true表示等比例缩放
        imgHookArray.push_back(imgH);//存放进柱子数组
        obstacleImgs.push_back(imgHookArray);//存放进障碍二维数组
    &#125;

    //初始化满血
    heroBlood=100;
    
    //预加载音效
    preLoadSound(&quot;res/hit.mp3&quot;);

    //播放背景音乐
    mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    //最后一个障碍物的序号
    lastObsIndex = -1;
    //得分
    score = 0;

    //加载记分数字图片资源
    for (int i = 0; i &lt; 10; i++)
    &#123;
        sprintf(name, &quot;res/sz/%d.png&quot;, i);
        loadimage(&amp;imgSZ[i], name);
    &#125;
&#125;

//创建障碍物
void createObstacle()
&#123;
    int i;
    for (i = 0; i &lt; OBSTACLE_COUNT; i++)//找一个没出现在窗口的
    &#123;
        if (obstacles[i].exist == false) //找到了
        &#123;
            break;
        &#125;
    &#125;
    if (i &gt;= OBSTACLE_COUNT) 
    &#123;
        return;
    &#125;
    obstacles[i].exist = true;
    obstacles[i].hited = false;
    obstacles[i].imgIndex = 0;
    //obstacles[i].type = (obstacle_type)(rand() % OBSTACLE_TYPE_COUNT);	
    obstacles[i].type = (obstacle_type)(rand() % 3);//因为柱子有四个，对前3个求余避免频繁出现
    
    if (lastObsIndex &gt;= 0 &amp;&amp; obstacles[lastObsIndex].type &gt;= HOOK1 &amp;&amp;
        obstacles[lastObsIndex].type &lt;= HOOK4 &amp;&amp;
        obstacles[i].type == LION &amp;&amp;
        obstacles[lastObsIndex].x &gt; (WIN_WIDTH - 500))//前提：上一个是柱子且距离不远，现在是狮子，
    &#123;
        obstacles[i].type = TORTOISE;//让狮子变乌龟
    &#125;
    lastObsIndex = i;//更新上一个

    if (obstacles[i].type == HOOK1) //四个柱子再来随机
    &#123;
        obstacles[i].type = (obstacle_type)((int)(obstacles[i].type) + rand() % 4);//0...3
    &#125;

    obstacles[i].x = WIN_WIDTH;//坐标
    obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
    
    if (obstacles[i].type == TORTOISE) 
    &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 5;
    &#125;
    else if (obstacles[i].type == LION) 
    &#123;
        obstacles[i].speed = 4;
        obstacles[i].power = 20;
    &#125;
    else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4)
    &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 20;
        obstacles[i].y = 0;
    &#125;
    obstacles[i].passed = false;//没通过
&#125;

//玩家和障碍物的“碰撞检测”处理
void checkHit()
&#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++)
    &#123;
        if (obstacles[i].exist &amp;&amp; obstacles[i].hited == false) //前提：障碍物存在且没撞过
        &#123;
            int a1x, a1y, a2x, a2y;//矩形对角点（左上角和右下角） 
            int off = 30;//比渲染图片要小一点的（使碰撞更合理）
            if (!heroDown) //下蹲和奔跑时图片坐标不太一样，所以分开讨论
            &#123;
                a1x = heroX + off;
                a1y = heroY + off;
                a2x = heroX + imgHeros[heroIndex].getwidth() - off;
                a2y = heroY + imgHeros[heroIndex].getheight();
            &#125;
            else //处于下蹲状态
            &#123;
                a1x = heroX + off;
                a1y = 345 - imgHeroDown[heroIndex].getheight();
                a2x = heroX + imgHeroDown[heroIndex].getwidth() - off;
                a2y = 345;
            &#125;

            //定义障碍物坐标
            IMAGE img = obstacleImgs[obstacles[i].type][obstacles[i].imgIndex];
            int b1x = obstacles[i].x + off;
            int b1y = obstacles[i].y + off;
            int b2x = obstacles[i].x + img.getwidth() - off;
            int b2y = obstacles[i].y + img.getheight() - 10;

            if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) &#123;
                heroBlood -= obstacles[i].power;
                printf(&quot;血量剩余 %d\n&quot;, heroBlood);
                playSound(&quot;res/hit.mp3&quot;);
                obstacles[i].hited = true;//碰撞完毕
            &#125;
        &#125;
    &#125;
&#125;

//让背景飞起来
void fly()
&#123;
    for (int i = 0; i &lt; 3; i++)
    &#123;
        bgX[i] -= bgSpeed[i];
        if (bgX[i] &lt; -WIN_WIDTH)//当图片滑到右顶端，让其重新回到左顶端
        &#123;
            bgX[i] = 0;
        &#125;
    &#125;
    
    //实现跳跃
    if (heroJump)
    &#123;
        if (heroY &lt; jumpHeightMax)
        &#123;
            heroJumpOff = 6;
        &#125;
        heroY += heroJumpOff;
        if (heroY &gt; 345 - imgHeros[0].getheight()) //落地
        &#123;
            heroJump = false;//已经完成一次跳跃
            heroJumpOff = -6;//恢复初值
        &#125;
    &#125;
    else if (heroDown)//实现下蹲
    &#123;
        static int count = 0;
        int delays[2] = &#123; 2,30 &#125;;//下蹲4ms一次，滑翔35ms一次
        count++;
        if (count &gt;= delays[heroIndex]) //避免下蹲和滑翔太快，采用count延迟时间
        &#123;
            count = 0;
            heroIndex++;
            if (heroIndex &gt;= 2) &#123;
                heroIndex = 0;
                heroDown = false;
            &#125;
        &#125;

    &#125;
    else //不跳跃或下蹲滑翔，才更换帧图片，保证跳跃或滑翔时，腿不动
    &#123;
        //1到12张依次播放
        heroIndex = (heroIndex + 1) % 12;
    &#125;

    //创建敌人
    static int frameCount = 0;
    static int enemyFre = 50;//敌人频率
    frameCount++;
    if (frameCount &gt; enemyFre) &#123;
        frameCount = 0;
        enemyFre = 50 + rand() % 50; //50...999
        createObstacle();
    &#125;
                                                        //if (torToiseExist)
                                                        //&#123;
                                                        //	torToiseX -= bgSpeed[2];//跟草坪速度一样
                                                        //	if (torToiseX &lt; -imgTortoise.getwidth())
                                                        //	&#123;
                                                        //		torToiseExist = false;
                                                        //	&#125;
                                                        //&#125;
    //更新所有障碍物的坐标
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) 
    &#123;
        if (obstacles[i].exist)
        &#123;
            obstacles[i].x -= obstacles[i].speed + bgSpeed[2];//还要减去草坪的速度
            if (obstacles[i].x &lt; -obstacleImgs[obstacles[i].type][0].getwidth() * 2) //*2残留久一点
            &#123;
                obstacles[i].exist = false;
            &#125;
            int len = obstacleImgs[obstacles[i].type].size();//计算该障碍物有多少张图片
            obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
        &#125;
    &#125;

    //玩家和障碍物的“碰撞检测”处理
    checkHit();
&#125;

//渲染游戏背景
void updateBg()
&#123;
    //putimagePNG2版本允许y&lt;0,开源版本不行
    putimagePNG2(bgX[0], 0, &amp;imBgs[0]);
    putimagePNG2(bgX[1], 119, &amp;imBgs[1]);
    putimagePNG2(bgX[2], 330, &amp;imBgs[2]);
&#125;

//人物跳跃
void jump() &#123;
    heroJump = true;
    update = true;//跳跃时没到30ms也要刷新
&#125;

//人物下蹲
void down() &#123;
    update = true;//直接更新
    heroDown = true;
    heroIndex = 0;//从第一张帧图片开始
&#125;

//处理用户按键的输入
void keyEvent() 
&#123;
    //scanf(&quot;%c&quot;, c);//等待用户输入，会直接阻塞程序的执行
    char ch;
    if (_kbhit()) //判断是否有按键输入
    &#123;
        ch = _getch();//_getch()不需要按下回车即可直接读取
        if (ch == &#39; &#39;) &#123;
            jump();
        &#125;
        else if (ch == &#39;a&#39;) &#123;
            down();
        &#125;
        //改进
        /*if (GetAsyncKeyState(VK_UP))
            &#123;
                jump();
            &#125;
            else if (GetAsyncKeyState(VK_DOWN)) &#123;
                down();
            &#125;*/
    &#125;
    
&#125;

//刷新（显示）障碍物
void updateEnemy()
&#123;
    //渲染小乌龟
    /*if (torToiseExist)
    &#123;
        putimagePNG2(torToiseX, torToiseY, WIN_WIDTH, &amp;imgTortoise);
    &#125;*/
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist)
        &#123;
            putimagePNG2(obstacles[i].x, obstacles[i].y, WIN_WIDTH,
                &amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
        &#125;
    &#125;
&#125;

//
void updateHero()
&#123;
    if (!heroDown)//不下蹲
    &#123;
        putimagePNG2(heroX, heroY, &amp;imgHeros[heroIndex]);//让人物动起来
    &#125;
    else//下蹲
    &#123;
        int y = 345 - imgHeroDown[heroIndex].getheight();
        putimagePNG2(heroX, y, &amp;imgHeroDown[heroIndex]);
    &#125;
&#125;

//更新血条
void updateBloodBar()
&#123;
    drawBloodBar(10, 10, 200, 20, 2,
        BLUE, DARKGRAY, RED, heroBlood / 100.0);
&#125;

//判断是否结束
void checkOver()
&#123;
    if (heroBlood &lt;= 0)
    &#123;
        loadimage(0, &quot;res/over.png&quot;);//0表示直接呈现在窗口
        FlushBatchDraw();//刷新
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);//关闭背景音乐
        system(&quot;pause&quot;);//暂停呈现页面
        //暂停之后，充币复活，或者直接开始下一局
        heroBlood = 100;
        score = 0;//分数清零
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;

//跨过障碍物加分
void checkScore() 
&#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) 
    &#123;
        //前提：存在，没通过，没撞，人物坐标在前
        if (obstacles[i].exist &amp;&amp;
            obstacles[i].passed == false &amp;&amp;
            obstacles[i].hited == false &amp;&amp;
            obstacles[i].x + obstacleImgs[obstacles[i].type][0].getwidth() &lt; heroX) 
        &#123;
            score++;
            obstacles[i].passed = true;
            printf(&quot;score:%d\n&quot;, score);
        &#125;
    &#125;
&#125;

void updateScore()
&#123;
    //50=&gt;&quot;50&quot;   &#39;5&#39;-&#39;0&#39;==5
    char str[8];
    sprintf(str, &quot;%d&quot;, score);
    //分数显示坐标
    int x = 20;
    int y = 35;
    for (int i = 0; str[i]; i++)
    &#123;
        int sz = str[i] - &#39;0&#39;;
        putimagePNG(x, y, &amp;imgSZ[sz]);
        x += imgSZ[sz].getwidth() + 5;
    &#125;
&#125;

void checkWin()
&#123;
    if (score &gt;= WIN_SCORE)
    &#123;
        FlushBatchDraw();
        mciSendString(&quot;play res/win.mp3&quot;, 0, 0, 0);
        Sleep(2000);//休眠2s，别太突然
        loadimage(0, &quot;res/win.png&quot;);
        FlushBatchDraw();
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);
        system(&quot;pause&quot;);
        //恢复初值
        heroBlood = 100;
        score = 0;
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;

int main()
&#123;
    init();
    //初始界面
    loadimage(0, &quot;res/over.png&quot;);//0表示直接呈现在窗口
    system(&quot;pause&quot;);//暂停呈现页面

    int timer = 0;
    while (1)
    &#123;
        keyEvent();//键盘输入
        timer += getDelay();//getDelay()返回距离上一次调用间隔的时间（单位：ms)，第一次调用时返回0
        if (timer &gt; 30)//30ms更新一次页面
        &#123;
            timer = 0;//重置
            update = true;//刷新
        &#125;
        if (update)
        &#123;
            update = false;
            //避免画面闪烁
            BeginBatchDraw();//开始绘画
            updateBg();//加while循环让背景动起来
            updateHero();//渲染玩家
            updateEnemy();//渲染障碍物
            updateBloodBar();//更新血条
            updateScore();
            checkWin();//检查是否胜利
            EndBatchDraw();//结束绘画
            checkOver();
            checkScore();
            
            fly();//改变位置
        &#125;
        //Sleep(30);//避免画面闪的太快
        //Sleep()缺点：在休眠期间内，按下按键，休眠结束后才响应
    &#125;
    system(&quot;pause&quot;);//即等待用户信号,不然控制台程序会一闪即过，你来不及看到执行结果。
&#125;
</code></pre>
<h2 id="2-头文件与常量定义"><a href="#2-头文件与常量定义" class="headerlink" title="2.头文件与常量定义"></a>2.头文件与常量定义</h2><pre><code class="c++">#include&lt;graphics.h&gt;//easyx图形库
#include&lt;stdio.h&gt;
#include&lt;conio.h&gt;//键盘输入
#include&lt;vector&gt;//使用动态数组
#include&quot;tools.h&quot;

using namespace std;//声明命名空间


#define WIN_SCORE 10
#define WIN_WIDTH 1012
#define WIN_HEIGHT 396
#define OBSTACLE_COUNT 10
</code></pre>
<h2 id="3-全局变量和结构体定义"><a href="#3-全局变量和结构体定义" class="headerlink" title="3.全局变量和结构体定义"></a>3.全局变量和结构体定义</h2><p>定义图片普遍采用一维数组，这样可以进行循环展示</p>
<pre><code class="c++">//背景图片
IMAGE imBgs[3];//采用一维数组
int bgX[3];//背景图片的x坐标
int bgSpeed[3] = &#123; 1,2,4 &#125;;//各层背景移动速度

//人物图像定义
IMAGE imgHeros[12];
int heroX;//玩家的X坐标
int heroY;//玩家的Y坐标
int heroIndex;//玩家奔跑的帧序号

bool heroJump;//表示玩家正在跳跃

int jumpHeightMax;//人物跳跃的最大高度
int heroJumpOff;//偏移量
int update;//表示是否需要马上刷新画面

int heroBlood;//英雄血量
int score;//得分

typedef enum &#123;
    TORTOISE,//乌龟 0
    LION,//狮子 1
    HOOK1,//障碍柱子
    HOOK2,
    HOOK3,
    HOOK4,
    OBSTACLE_TYPE_COUNT//表示一共的个数（这里6种类型）
&#125; obstacle_type;

//IMAGE obstacleImgs[3][12];
//动态存储，避免浪费空间
vector&lt;vector&lt;IMAGE&gt;&gt;obstacleImgs;//存放所有障碍物的各个图片

//使用结构体封装优化障碍物
typedef struct obstacle &#123;
    obstacle_type type;//障碍物的类型
    int imgIndex;//当前显示的图片的序号
    int x, y;//障碍物的坐标
    int speed;//速度
    int power;//杀伤力
    bool exist;//是否存在
    bool hited;//表示是否发生碰撞
    bool passed;//表示是否已经被通过
&#125;obstacle_t;

obstacle_t obstacles[OBSTACLE_COUNT];
int lastObsIndex;//记录上一个障碍物的序号，解决柱子和狮子同时出现的BUG

//定义下蹲帧图片
IMAGE imgHeroDown[2];
bool heroDown;//表示玩家是否处于下蹲状态

//定义数字资源
IMAGE imgSZ[10];
</code></pre>
<h2 id="4-游戏初始化"><a href="#4-游戏初始化" class="headerlink" title="4.游戏初始化"></a>4.游戏初始化</h2><p>创建窗口，导入图片资源，变量初始化</p>
<pre><code class="c++">//游戏的初始化
void init()
&#123;
    //创建游戏窗口
    initgraph(WIN_WIDTH, WIN_HEIGHT);//EW_SHOWCONSOLE显示控制台

    //加载背景资源
    char name[64];
    for (int i = 0; i &lt; 3; i++)
    &#123;
        //&quot;res/bg001.png&quot; &quot;res/bg002.png&quot; &quot;res/bg003.png&quot;
        sprintf(name, &quot;res/bg%03d.png&quot;, i + 1);//sprintf函数：发送格式化输出到 string 所指向的字符串
        loadimage(&amp;imBgs[i], name);//读取资源
        bgX[i] = 0;//初始化X坐标
    &#125;

    //加载Hero奔跑的图片帧素材
    for (int i = 0; i &lt; 12; i++)
    &#123;
        //&quot;res/hero1.png&quot;...&quot;res/hero12.png&quot;
        sprintf(name, &quot;res/hero%d.png&quot;, i + 1);
        loadimage(&amp;imgHeros[i], name);
    &#125;

    //设置玩家的初始位置
    heroX = WIN_WIDTH * 0.5 - imgHeros[0].getwidth() * 0.5;
    heroY = 345 - imgHeros[0].getheight();
    heroIndex = 0;

    heroJump = false;//初始不跳
    jumpHeightMax = 345 - imgHeros[0].getheight() -110;//跳跃最大高度
    heroJumpOff = -6;//每次向上跳6

    update = true;//开始刷新


    IMAGE imgTort;//定义小乌龟
    loadimage(&amp;imgTort, &quot;res/t1.png&quot;);
    vector&lt;IMAGE&gt; imgTortArray;
    imgTortArray.push_back(imgTort);//存进数组
    obstacleImgs.push_back(imgTortArray);//存进二维数组

    IMAGE imgLion;//定义小狮子
    vector&lt;IMAGE&gt; imgLionArray;
    for (int i = 0; i &lt; 6; i++) 
    &#123;
        sprintf(name, &quot;res/p%d.png&quot;, i + 1);
        loadimage(&amp;imgLion, name);
        imgLionArray.push_back(imgLion);//存进数组
    &#125;
    obstacleImgs.push_back(imgLionArray);//存进二维数组

    //初始化障碍池
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++)
    &#123;
        obstacles[i].exist = false;
    &#125;

    //加载下蹲素材
    loadimage(&amp;imgHeroDown[0], &quot;res/d1.png&quot;);
    loadimage(&amp;imgHeroDown[1], &quot;res/d2.png&quot;);
    heroDown = false;

    //加载柱子障碍物素材
    IMAGE imgH;
    for (int i = 0; i &lt; 4; i++) &#123;
        vector&lt;IMAGE&gt; imgHookArray;
        sprintf(name, &quot;res/h%d.png&quot;, i + 1);
        loadimage(&amp;imgH, name, 63, 260, true);//后面三个参数分别是width，height，true表示等比例缩放
        imgHookArray.push_back(imgH);//存放进柱子数组
        obstacleImgs.push_back(imgHookArray);//存放进障碍二维数组
    &#125;

    //初始化满血
    heroBlood=100;
    
    //预加载音效
    preLoadSound(&quot;res/hit.mp3&quot;);

    //播放背景音乐
    mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    //最后一个障碍物的序号
    lastObsIndex = -1;
    //得分
    score = 0;

    //加载记分数字图片资源
    for (int i = 0; i &lt; 10; i++)
    &#123;
        sprintf(name, &quot;res/sz/%d.png&quot;, i);
        loadimage(&amp;imgSZ[i], name);
    &#125;
&#125;
</code></pre>
<h4 id="preLoadSound-函数"><a href="#preLoadSound-函数" class="headerlink" title="preLoadSound()函数"></a>preLoadSound()函数</h4><p>预加载音效，解决第一个障碍物没有声音</p>
<p>这是工具包函数，直接调用即可</p>
<pre><code class="c++">void  preLoadSound(const char* name) &#123;
    char cmd[512];
    sprintf_s(cmd, sizeof(cmd), &quot;open %s alias %s-1&quot;, name, name);
    mciSendString(cmd, 0, 0, 0);
    sprintf_s(cmd, sizeof(cmd), &quot;open %s alias %s-2&quot;, name, name);
    mciSendString(cmd, 0, 0, 0);
&#125;
</code></pre>
<h2 id="5-画面，人物，敌人动起来"><a href="#5-画面，人物，敌人动起来" class="headerlink" title="5.画面，人物，敌人动起来"></a>5.画面，人物，敌人动起来</h2><pre><code class="c++">//让背景飞起来
void fly()
&#123;
    for (int i = 0; i &lt; 3; i++)
    &#123;
        bgX[i] -= bgSpeed[i];
        if (bgX[i] &lt; -WIN_WIDTH)//当图片滑到右顶端，让其重新回到左顶端
        &#123;
            bgX[i] = 0;
        &#125;
    &#125;
    
    //实现跳跃
    if (heroJump)
    &#123;
        if (heroY &lt; jumpHeightMax)
        &#123;
            heroJumpOff = 6;
        &#125;
        heroY += heroJumpOff;//一开始是-6
        if (heroY &gt; 345 - imgHeros[0].getheight()) //落地
        &#123;
            heroJump = false;//已经完成一次跳跃
            heroJumpOff = -6;//恢复初值
        &#125;
    &#125;
    else if (heroDown)//实现下蹲
    &#123;
        static int count = 0;
        int delays[2] = &#123; 2,30 &#125;;//下蹲4ms一次，滑翔35ms一次
        count++;
        if (count &gt;= delays[heroIndex]) //避免下蹲和滑翔太快，采用count延迟时间
        &#123;
            count = 0;
            heroIndex++;
            if (heroIndex &gt;= 2) &#123;
                heroIndex = 0;
                heroDown = false;
            &#125;
        &#125;

    &#125;
    else //不跳跃或下蹲滑翔，才更换帧图片，保证跳跃或滑翔时，腿不动
    &#123;
        //1到12张依次播放
        heroIndex = (heroIndex + 1) % 12;
    &#125;

    //创建敌人
    static int frameCount = 0;
    static int enemyFre = 50;//敌人频率
    frameCount++;
    if (frameCount &gt; enemyFre) &#123;
        frameCount = 0;
        enemyFre = 50 + rand() % 50; //50...99
        createObstacle();
    &#125;
                                                        
    //更新所有障碍物的坐标
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) 
    &#123;
        if (obstacles[i].exist)
        &#123;
            obstacles[i].x -= obstacles[i].speed + bgSpeed[2];//还要减去草坪的速度
            if (obstacles[i].x &lt; -obstacleImgs[obstacles[i].type][0].getwidth() * 2) //*2残留久一点
            &#123;
                obstacles[i].exist = false;
            &#125;
            int len = obstacleImgs[obstacles[i].type].size();//计算该障碍物有多少张图片
            obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
        &#125;
    &#125;

    //玩家和障碍物的“碰撞检测”处理
    checkHit();
&#125;
</code></pre>
<h3 id="实现游戏背景"><a href="#实现游戏背景" class="headerlink" title="实现游戏背景"></a>实现游戏背景</h3><p>设计游戏背景，采用三重背景不同的速度同时移动</p>
<p>循环滚动背景实现原理：背景图片宽度是窗口的两倍</p>
<pre><code class="c++">for (int i = 0; i &lt; 3; i++)
    &#123;
        bgX[i] -= bgSpeed[i];
        if (bgX[i] &lt; -WIN_WIDTH)//当图片滑到右顶端，让其重新回到左顶端
        &#123;
            bgX[i] = 0;
        &#125;
    &#125;
</code></pre>
<h3 id="实现人物跳跃下蹲"><a href="#实现人物跳跃下蹲" class="headerlink" title="实现人物跳跃下蹲"></a>实现人物跳跃下蹲</h3><pre><code class="c++">//实现跳跃
    if (heroJump)
    &#123;
        if (heroY &lt; jumpHeightMax)
        &#123;
            heroJumpOff = 6;
        &#125;
        heroY += heroJumpOff;//一开始是-6
        if (heroY &gt; 345 - imgHeros[0].getheight()) //落地
        &#123;
            heroJump = false;//已经完成一次跳跃
            heroJumpOff = -6;//恢复初值
        &#125;
    &#125;
    else if (heroDown)//实现下蹲
    &#123;
        static int count = 0;
        int delays[2] = &#123; 2,30 &#125;;//下蹲4ms一次，滑翔35ms一次
        count++;
        if (count &gt;= delays[heroIndex]) //避免下蹲和滑翔太快，采用count延迟时间
        &#123;
            count = 0;
            heroIndex++;
            if (heroIndex &gt;= 2) &#123;
                heroIndex = 0;
                heroDown = false;
            &#125;
        &#125;

    &#125;
    else //不跳跃或下蹲滑翔，才更换帧图片，保证跳跃或滑翔时，腿不动
    &#123;
        //1到12张依次播放
        heroIndex = (heroIndex + 1) % 12;
    &#125;
</code></pre>
<h4 id="JUMP"><a href="#JUMP" class="headerlink" title="JUMP"></a>JUMP</h4><pre><code class="c++">//人物跳跃
void jump() &#123;
    heroJump = true;
    update = true;//跳跃时没到30ms也要刷新
&#125;
</code></pre>
<h4 id="DOWN"><a href="#DOWN" class="headerlink" title="DOWN"></a>DOWN</h4><pre><code class="c++">//人物下蹲
void down() &#123;
    update = true;//直接更新
    heroDown = true;
    heroIndex = 0;//从第一张帧图片开始
&#125;
</code></pre>
<h3 id="创建敌人"><a href="#创建敌人" class="headerlink" title="创建敌人"></a>创建敌人</h3><pre><code class="c++">//创建障碍物
void createObstacle()
&#123;
    int i;
    for (i = 0; i &lt; OBSTACLE_COUNT; i++)//找一个没出现在窗口的
    &#123;
        if (obstacles[i].exist == false) //找到了
        &#123;
            break;
        &#125;
    &#125;
    if (i &gt;= OBSTACLE_COUNT) 
    &#123;
        return;
    &#125;
    obstacles[i].exist = true;
    obstacles[i].hited = false;
    obstacles[i].imgIndex = 0;
    //obstacles[i].type = (obstacle_type)(rand() % OBSTACLE_TYPE_COUNT);	
    obstacles[i].type = (obstacle_type)(rand() % 3);//因为柱子有四个，对前3个敌人求余避免频繁出现
    
    //解决柱子与狮子同时出现BUG
    if (lastObsIndex &gt;= 0 &amp;&amp; obstacles[lastObsIndex].type &gt;= HOOK1 &amp;&amp;
        obstacles[lastObsIndex].type &lt;= HOOK4 &amp;&amp;
        obstacles[i].type == LION &amp;&amp;
        obstacles[lastObsIndex].x &gt; (WIN_WIDTH - 500))//前提：上一个是柱子且距离不远，现在是狮子，
    &#123;
        obstacles[i].type = TORTOISE;//让狮子变乌龟
    &#125;
    lastObsIndex = i;//更新上一个

    if (obstacles[i].type == HOOK1) //四个柱子再来随机
    &#123;
        obstacles[i].type = (obstacle_type)((int)(obstacles[i].type) + rand() % 4);//0...3
    &#125;

    obstacles[i].x = WIN_WIDTH;//坐标
    obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
    
    if (obstacles[i].type == TORTOISE) 
    &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 5;
    &#125;
    else if (obstacles[i].type == LION) 
    &#123;
        obstacles[i].speed = 4;
        obstacles[i].power = 20;
    &#125;
    else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4)
    &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 20;
        obstacles[i].y = 0;
    &#125;
    obstacles[i].passed = false;//没通过
&#125;
</code></pre>
<h4 id="优化障碍物的出现频率"><a href="#优化障碍物的出现频率" class="headerlink" title="优化障碍物的出现频率"></a>优化障碍物的出现频率</h4><pre><code class="c++">//创建敌人
    static int frameCount = 0;
    static int enemyFre = 50;//敌人频率
    frameCount++;
    if (frameCount &gt; enemyFre) &#123;
        frameCount = 0;
        enemyFre = 50 + rand() % 50; //50...99
        createObstacle();
    &#125;
</code></pre>
<h3 id="敌人动起来"><a href="#敌人动起来" class="headerlink" title="敌人动起来"></a>敌人动起来</h3><pre><code class="c++">//更新所有障碍物的坐标
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) 
    &#123;
        if (obstacles[i].exist)
        &#123;
            obstacles[i].x -= obstacles[i].speed + bgSpeed[2];//还要减去草坪的速度
            if (obstacles[i].x &lt; -obstacleImgs[obstacles[i].type][0].getwidth() * 2) //*2残留久一点
            &#123;
                obstacles[i].exist = false;
            &#125;
            int len = obstacleImgs[obstacles[i].type].size();//计算该障碍物有多少张图片
            obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
        &#125;
    &#125;
</code></pre>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><pre><code class="c++">//玩家和障碍物的“碰撞检测”处理
void checkHit()
&#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++)
    &#123;
        if (obstacles[i].exist &amp;&amp; obstacles[i].hited == false) //前提：障碍物存在且没撞过
        &#123;
            int a1x, a1y, a2x, a2y;//矩形对角点（左上角和右下角） 
            int off = 30;//比渲染图片要小一点的（使碰撞更合理）
            if (!heroDown) //下蹲和奔跑时图片坐标不太一样，所以分开讨论
            &#123;
                a1x = heroX + off;
                a1y = heroY + off;
                a2x = heroX + imgHeros[heroIndex].getwidth() - off;
                a2y = heroY + imgHeros[heroIndex].getheight();
            &#125;
            else //处于下蹲状态
            &#123;
                a1x = heroX + off;
                a1y = 345 - imgHeroDown[heroIndex].getheight();
                a2x = heroX + imgHeroDown[heroIndex].getwidth() - off;
                a2y = 345;
            &#125;

            //定义障碍物坐标
            IMAGE img = obstacleImgs[obstacles[i].type][obstacles[i].imgIndex];
            int b1x = obstacles[i].x + off;
            int b1y = obstacles[i].y + off;
            int b2x = obstacles[i].x + img.getwidth() - off;
            int b2y = obstacles[i].y + img.getheight() - 10;
            //rectIntersect（）函数判断两矩形是否相交
            if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) &#123;
                heroBlood -= obstacles[i].power;
                printf(&quot;血量剩余 %d\n&quot;, heroBlood);
                playSound(&quot;res/hit.mp3&quot;);
                obstacles[i].hited = true;//碰撞完毕
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="rectIntersect（）函数"><a href="#rectIntersect（）函数" class="headerlink" title="rectIntersect（）函数"></a>rectIntersect（）函数</h4><p>判断两矩形是否相交</p>
<pre><code class="c++">//设A[x01,y01,x02,y02]  B[x11,y11,x12,y12].
bool rectIntersect(int x01, int y01, int x02, int y02,
    int x11, int y11, int x12, int y12)
&#123;
    int zx = abs(x01 + x02 - x11 - x12);
    int x = abs(x01 - x02) + abs(x11 - x12);
    int zy = abs(y01 + y02 - y11 - y12);
    int y = abs(y01 - y02) + abs(y11 - y12);
    return  (zx &lt;= x &amp;&amp; zy &lt;= y);
&#125;
</code></pre>
<h4 id="playSound-函数"><a href="#playSound-函数" class="headerlink" title="playSound()函数"></a>playSound()函数</h4><p>新建一个接口，避免重叠音</p>
<pre><code class="c++">void  playSound(const char* name) &#123;
    static int index = 1;
    char cmd[512];

    if (index == 1) &#123;
        sprintf_s(cmd, sizeof(cmd), &quot;play %s-1&quot;, name);
        mciSendString(cmd, 0, 0, 0);
        sprintf_s(cmd, sizeof(cmd), &quot;close %s-2&quot;, name);
        mciSendString(cmd, 0, 0, 0);
        sprintf_s(cmd, sizeof(cmd), &quot;open %s alias %s-2&quot;, name, name);
        mciSendString(cmd, 0, 0, 0);
        index++;
    &#125;
    else if (index == 2) &#123;
        sprintf_s(cmd, sizeof(cmd), &quot;play %s-2&quot;, name);
        mciSendString(cmd, 0, 0, 0);
        sprintf_s(cmd, sizeof(cmd), &quot;close %s-1&quot;, name);
        mciSendString(cmd, 0, 0, 0);
        sprintf_s(cmd, sizeof(cmd), &quot;open %s alias %s-1&quot;, name, name);
        mciSendString(cmd, 0, 0, 0);
        index = 1;
    &#125;
&#125;
</code></pre>
<h2 id="6-渲染游戏元素"><a href="#6-渲染游戏元素" class="headerlink" title="6.渲染游戏元素"></a>6.渲染游戏元素</h2><h4 id="渲染游戏背景"><a href="#渲染游戏背景" class="headerlink" title="渲染游戏背景"></a>渲染游戏背景</h4><p>  遇到问题：背景图片的png格式图片出现黑色</p>
<p>解决：使用工具函数putimagePNG2()</p>
<pre><code class="c++">//渲染游戏背景
void updateBg()
&#123;
    //putimagePNG2版本允许y&lt;0,开源版本不行
    putimagePNG2(bgX[0], 0, &amp;imBgs[0]);
    putimagePNG2(bgX[1], 119, &amp;imBgs[1]);
    putimagePNG2(bgX[2], 330, &amp;imBgs[2]);
&#125;
</code></pre>
<h5 id="putimagePNG2-函数"><a href="#putimagePNG2-函数" class="headerlink" title="putimagePNG2()函数"></a>putimagePNG2()函数</h5><p>载入PNG图并去透明部分</p>
<pre><code class="c++">// 适用于 y &lt;0 以及y&gt;0的任何情况
void putimagePNG2(int x, int y, int winWidth, IMAGE* picture) &#123;
    IMAGE imgTmp;
    if (y &lt; 0) &#123;
        SetWorkingImage(picture);
        getimage(&amp;imgTmp, 0, -y,
            picture-&gt;getwidth(), picture-&gt;getheight() + y);
        SetWorkingImage();
        y = 0;
        picture = &amp;imgTmp;
    &#125;

    if (x &lt; 0) &#123;
        SetWorkingImage(picture);
        getimage(&amp;imgTmp, -x, 0, picture-&gt;getwidth() + x, picture-&gt;getheight());
        SetWorkingImage();
        x = 0;
        picture = &amp;imgTmp;
    &#125;
    else if (x &gt;= winWidth) &#123;
        return;
    &#125;
    else if (x &gt; winWidth-picture-&gt;getwidth()) &#123;
        SetWorkingImage(picture);
        getimage(&amp;imgTmp, 0, 0, winWidth - x, picture-&gt;getheight());
        SetWorkingImage();
        picture = &amp;imgTmp;
    &#125;

    putimagePNG(x, y, picture);
&#125;
</code></pre>
<h4 id="渲染敌人"><a href="#渲染敌人" class="headerlink" title="渲染敌人"></a>渲染敌人</h4><pre><code class="c++">//刷新（显示）障碍物
void updateEnemy()
&#123;
    //渲染小乌龟
    /*if (torToiseExist)
    &#123;
        putimagePNG2(torToiseX, torToiseY, WIN_WIDTH, &amp;imgTortoise);
    &#125;*/
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist)
        &#123;
            putimagePNG2(obstacles[i].x, obstacles[i].y, WIN_WIDTH,
                &amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="渲染角色"><a href="#渲染角色" class="headerlink" title="渲染角色"></a>渲染角色</h4><pre><code class="c++">void updateHero()
&#123;
    if (!heroDown)//不下蹲
    &#123;
        putimagePNG2(heroX, heroY, &amp;imgHeros[heroIndex]);//让人物动起来
    &#125;
    else//下蹲
    &#123;
        int y = 345 - imgHeroDown[heroIndex].getheight();
        putimagePNG2(heroX, y, &amp;imgHeroDown[heroIndex]);
    &#125;
&#125;
</code></pre>
<h2 id="7-控制键盘输入"><a href="#7-控制键盘输入" class="headerlink" title="7.控制键盘输入"></a>7.控制键盘输入</h2><pre><code class="c++">//处理用户按键的输入
void keyEvent() 
&#123;
    //scanf(&quot;%c&quot;, c);//等待用户输入，会直接阻塞程序的执行
    char ch;
    if (_kbhit()) //判断是否有按键输入
    &#123;
        ch = _getch();//_getch()不需要按下回车即可直接读取
        if (ch == &#39; &#39;) &#123;
            jump();
        &#125;
        else if (ch == &#39;a&#39;) &#123;
            down();
        &#125;
    &#125;
    
&#125;
</code></pre>
<h2 id="8-显示血条"><a href="#8-显示血条" class="headerlink" title="8.显示血条"></a>8.显示血条</h2><pre><code class="c++">//更新血条
void updateBloodBar()
&#123;
    drawBloodBar(10, 10, 200, 20, 2,
        BLUE, DARKGRAY, RED, heroBlood / 100.0);
&#125;
</code></pre>
<pre><code class="c++">void drawBloodBar(int x, int y, int width, int height, int lineWidth, int boardColor, int emptyColor, int fillColor, float percent) &#123;
    LINESTYLE lineStyle;
    getlinestyle(&amp;lineStyle);
    int lineColor = getlinecolor();
    int fileColor = getfillcolor();

    if (percent &lt; 0) &#123;
        percent = 0;
    &#125;

    setlinecolor(BLUE);
    setlinestyle(PS_SOLID | PS_ENDCAP_ROUND, lineWidth);
    setfillcolor(emptyColor);
    fillrectangle(x, y, x + width, y + height);
    setlinestyle(PS_SOLID | PS_ENDCAP_FLAT, 0);
    setfillcolor(fillColor);
    setlinecolor(fillColor);
    if (percent &gt; 0) &#123;
        fillrectangle(x + 0.5 * lineWidth, y + lineWidth * 0.5, x + width * percent, y + height - 0.5 * lineWidth);
    &#125;
    
    setlinecolor(lineColor);
    setfillcolor(fillColor);
    setlinestyle(&amp;lineStyle);
&#125;
</code></pre>
<h2 id="9-结束判断"><a href="#9-结束判断" class="headerlink" title="9.结束判断"></a>9.结束判断</h2><pre><code class="c++">//判断是否结束
void checkOver()
&#123;
    if (heroBlood &lt;= 0)
    &#123;
        loadimage(0, &quot;res/over.png&quot;);//0表示直接呈现在窗口
        FlushBatchDraw();//刷新
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);//关闭背景音乐
        system(&quot;pause&quot;);//暂停呈现页面
        //暂停之后，充币复活，或者直接开始下一局
        heroBlood = 100;
        score = 0;//分数清零
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;
</code></pre>
<h2 id="10-显示分数"><a href="#10-显示分数" class="headerlink" title="10.显示分数"></a>10.显示分数</h2><pre><code class="c++">//跨过障碍物加分
void checkScore() 
&#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) 
    &#123;
        //前提：存在，没通过，没撞，人物坐标在前
        if (obstacles[i].exist &amp;&amp;
            obstacles[i].passed == false &amp;&amp;
            obstacles[i].hited == false &amp;&amp;
            obstacles[i].x + obstacleImgs[obstacles[i].type][0].getwidth() &lt; heroX) 
        &#123;
            score++;
            obstacles[i].passed = true;
            printf(&quot;score:%d\n&quot;, score);
        &#125;
    &#125;
&#125;

void updateScore()
&#123;
    //50=&gt;&quot;50&quot;   &#39;5&#39;-&#39;0&#39;==5
    char str[8];
    sprintf(str, &quot;%d&quot;, score);
    //分数显示坐标
    int x = 20;
    int y = 35;
    for (int i = 0; str[i]; i++)
    &#123;
        int sz = str[i] - &#39;0&#39;;
        putimagePNG(x, y, &amp;imgSZ[sz]);
        x += imgSZ[sz].getwidth() + 5;
    &#125;
&#125;
</code></pre>
<h2 id="11-判断游戏胜利"><a href="#11-判断游戏胜利" class="headerlink" title="11.判断游戏胜利"></a>11.判断游戏胜利</h2><pre><code class="c++">void checkWin()
&#123;
    if (score &gt;= WIN_SCORE)
    &#123;
        FlushBatchDraw();
        mciSendString(&quot;play res/win.mp3&quot;, 0, 0, 0);
        Sleep(2000);//休眠2s，别太突然
        loadimage(0, &quot;res/win.png&quot;);
        FlushBatchDraw();
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);
        system(&quot;pause&quot;);
        //恢复初值
        heroBlood = 100;
        score = 0;
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;
</code></pre>
<h2 id="12-优化帧等待"><a href="#12-优化帧等待" class="headerlink" title="12.优化帧等待"></a>12.优化帧等待</h2><p>Sleep()缺点：在休眠期间内，按下按键，休眠结束后才响应</p>
<p>解决方案：使用工具函数getDelay()</p>
<pre><code class="c++">int main()
&#123;
    init();
    //初始界面
    loadimage(0, &quot;res/over.png&quot;);//0表示直接呈现在窗口
    system(&quot;pause&quot;);//暂停呈现页面
    int timer = 0;
    while (1)
    &#123;
        keyEvent();//键盘输入
        timer += getDelay();//getDelay()返回距离上一次调用间隔的时间（单位：ms)，第一次调用时返回0
        if (timer &gt; 30)//30ms更新一次页面
        &#123;
            timer = 0;//重置
            update = true;//刷新
        &#125;
        if (update)
        &#123;
            update = false;
            //避免画面闪烁
            BeginBatchDraw();//开始绘画
            updateBg();//加while循环让背景动起来
            updateHero();//渲染玩家
            updateEnemy();//渲染障碍物
            updateBloodBar();//更新血条
            updateScore();
            checkWin();//检查是否胜利
            EndBatchDraw();//结束绘画
            checkOver();
            checkScore();
            
            fly();//改变位置
        &#125;
        //Sleep(30);//避免画面闪的太快
        //Sleep()缺点：在休眠期间内，按下按键，休眠结束后才响应
    &#125;
    system(&quot;pause&quot;);//即等待用户信号,不然控制台程序会一闪即过，你来不及看到执行结果。
&#125;
</code></pre>
<h4 id="getDelay-函数"><a href="#getDelay-函数" class="headerlink" title="getDelay()函数"></a>getDelay()函数</h4><p>&#x2F;&#x2F;返回距离上一次调用间隔的时间（单位：ms)，第一次调用时返回0</p>
<pre><code class="c++">int getDelay() &#123;
    static unsigned long long lastTime = 0;
    unsigned long long currentTime = GetTickCount();
    if (lastTime == 0) &#123;
        lastTime = currentTime;
        return 0;
    &#125;
    else &#123;
        int ret = currentTime - lastTime;
        lastTime = currentTime;
        return ret;
    &#125;
&#125;
</code></pre>
<h2 id="13-软件打包"><a href="#13-软件打包" class="headerlink" title="13.软件打包"></a>13.软件打包</h2><h2 id="14-添加英雄技能"><a href="#14-添加英雄技能" class="headerlink" title="14.添加英雄技能"></a>14.添加英雄技能</h2><h3 id="变大技能"><a href="#变大技能" class="headerlink" title="变大技能"></a>变大技能</h3><p>问题：</p>
<p>通过按键来测试功能</p>
<p>1.如何变大？</p>
<p>2.如何下蹲时还变大</p>
<p>3.如何碰撞敌人不扣血，敌人消失，还加分</p>
<p>4.实现捡技能包实现功能</p>
<p>临时</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;graphics.h&gt;
#include&lt;conio.h&gt;
#include&lt;vector&gt;
#include &quot;tools.h&quot;

using namespace std;

#define WIN_SCORE 99

#define WIN_WIDTH 1012
#define WIN_HEIGHT 396
#define OBSTACLE_COUNT 10

IMAGE imgBgs[3];
int bgX[3];
int bgSpeed[3] = &#123; 1,2,4 &#125;;

IMAGE imgHeros[12];
int heroX;
int heroY;
int heroIndex;

bool heroJump;

int jumpHeightMax;
int heroJumpOff;
int update;

//IMAGE imgTortoise;
//int torToiseX;
//int torToiseY;
//bool torToiseExist;

int heroBlood;
int score;

typedef enum &#123;
    TORTOISE,
    LION,
    HOOK1,
    HOOK2,
    HOOK3,
    HOOK4,
    OBSTACLE_TYPE_COUNT
&#125; obstacle_type;

vector&lt;vector&lt;IMAGE&gt;&gt;obstacleImgs;

typedef struct obstacle &#123;
    obstacle_type type;
    int imgIndex;
    int x, y;
    int speed;
    int power;
    bool exist;
    bool hited;
    bool passed;
&#125;obstacle_t;
typedef struct bullet &#123;
    IMAGE img;
    int x, y;
    int speed;
    //bool exist;
&#125;bullet_t;
vector&lt;bullet_t&gt; bullets;
obstacle_t obstacles[OBSTACLE_COUNT];
int lastObsIndex;

IMAGE imgHeroDown[2];
bool heroDown;

IMAGE imgSZ[10];

void init() &#123;
    initgraph(WIN_WIDTH, WIN_HEIGHT,EW_SHOWCONSOLE);

    char name[64];
    for (int i = 0; i &lt; 3; i++) &#123;
        sprintf(name, &quot;res/bg%03d.png&quot;, i + 1);
        loadimage(&amp;imgBgs[i], name);
        //loadimage(&amp;imgBgs[i], &quot;res/bg001.png&quot;);
        bgX[i] = 0;
    &#125;
    for (int i = 0; i &lt; 12; i++) &#123;
        sprintf(name, &quot;res/hero%d.png&quot;, i + 1);
        loadimage(&amp;imgHeros[i], name);
    &#125;
    heroX = WIN_WIDTH * 0.5 - imgHeros[0].getwidth() * 0.5;
    heroY = 345 - imgHeros[0].getheight();
    heroIndex = 0;
    heroJump = false;
    jumpHeightMax = 345 - imgHeros[0].getheight() - 120;
    heroJumpOff = -4;
    update = true;
    //loadimage(&amp;imgTortoise, &quot;res/t1.png&quot;);
    //torToiseExist = false;
    //torToiseY = 345 - imgTortoise.getheight()+5;
    IMAGE imgTort;
    loadimage(&amp;imgTort, &quot;res/t1.png&quot;);
    vector&lt;IMAGE&gt; imgTortArray;
    imgTortArray.push_back(imgTort);
    obstacleImgs.push_back(imgTortArray);

    IMAGE imgLion;
    vector&lt;IMAGE&gt; imgLionArray;
    for (int i = 0; i &lt; 6; i++) &#123;
        sprintf(name, &quot;res/p%d.png&quot;, i + 1);
        loadimage(&amp;imgLion, name);
        imgLionArray.push_back(imgLion);
    &#125;
    obstacleImgs.push_back(imgLionArray);

    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        obstacles[i].exist = false;
    &#125;

    loadimage(&amp;imgHeroDown[0], &quot;res/d1.png&quot;);
    loadimage(&amp;imgHeroDown[1], &quot;res/d2.png&quot;);
    heroDown = false;

    IMAGE imgH;
    for (int i = 0; i &lt; 4; i++) &#123;
        vector&lt;IMAGE&gt; imgHookArray;
        sprintf(name, &quot;res/h%d.png&quot;, i + 1);
        loadimage(&amp;imgH, name, 63, 260, true);
        imgHookArray.push_back(imgH);
        obstacleImgs.push_back(imgHookArray);
    &#125;

    heroBlood = 100;

    preLoadSound(&quot;res/hit.mp3&quot;);
    mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    lastObsIndex = -1;
    score = 0;

    for (int i = 0; i &lt; 10; i++) &#123;
        sprintf(name, &quot;res/sz/%d.png&quot;, i);
        loadimage(&amp;imgSZ[i], name);
    &#125;
&#125;

void createObstacle() &#123;
    int i;
    for (i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist == false) &#123;
            break;
        &#125;
    &#125;
    if (i &gt;= OBSTACLE_COUNT) &#123;
        return;
    &#125;
    obstacles[i].exist = true;
    obstacles[i].hited = false;
    obstacles[i].imgIndex = 0;
    //obstacles[i].type = (obstacle_type)(rand() % OBSTACLE_TYPE_COUNT);
    obstacles[i].type = (obstacle_type)(rand() % 3);

    if (lastObsIndex &gt;= 0 &amp;&amp; obstacles[lastObsIndex].type &gt;= HOOK1 &amp;&amp;
        obstacles[lastObsIndex].type &lt;= HOOK4 &amp;&amp;
        obstacles[i].type == LION &amp;&amp;
        obstacles[lastObsIndex].x &gt; (WIN_WIDTH - 500)) &#123;
        obstacles[i].type = TORTOISE;
    &#125;
    lastObsIndex = i;

    if (obstacles[i].type == HOOK1) &#123;
        obstacles[i].type = (obstacle_type)((int)(obstacles[i].type) + rand() % 4);
    &#125;
    obstacles[i].x = WIN_WIDTH;
    obstacles[i].y = 345 + 5 - obstacleImgs[obstacles[i].type][0].getheight();
    if (obstacles[i].type == TORTOISE) &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 5;
    &#125;
    else if (obstacles[i].type == LION) &#123;
        obstacles[i].speed = 4;
        obstacles[i].power = 20;
    &#125;
    else if (obstacles[i].type &gt;= HOOK1 &amp;&amp; obstacles[i].type &lt;= HOOK4) &#123;
        obstacles[i].speed = 0;
        obstacles[i].power = 20;
        obstacles[i].y = 0;
    &#125;
    obstacles[i].passed = false;
&#125;

void checkHit() &#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist &amp;&amp; obstacles[i].hited==false  )&#123;
            int a1x, a1y, a2x, a2y;
            int off = 30;
            if (!heroDown) &#123;
                a1x = heroX + off;
                a1y = heroY + off;
                a2x = heroX + imgHeros[heroIndex].getwidth() - off;
                a2y = heroY + imgHeros[heroIndex].getheight();
            &#125;
            else &#123;
                a1x = heroX + off;
                a1y = 345 - imgHeroDown[heroIndex].getheight();
                a2x = heroX + imgHeroDown[heroIndex].getwidth() - off;
                a2y = 345;
            &#125;

            IMAGE img = obstacleImgs[obstacles[i].type][obstacles[i].imgIndex];
            int b1x = obstacles[i].x + off;
            int b1y = obstacles[i].y + off;
            int b2x = obstacles[i].x + img.getwidth() - off;
            int b2y = obstacles[i].y + img.getheight() - 10;

            if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) &#123;
                heroBlood -= obstacles[i].power;
                printf(&quot;血量剩余 %d\n&quot;, heroBlood);
                playSound(&quot;res/hit.mp3&quot;);
                obstacles[i].hited = true;
            &#125;
        &#125;
    &#125;
&#125;

//void delete_bullet() &#123;
//	for (vector&lt;bullet_t&gt;::iterator it = bullets.begin(); it != bullets.end(); it++) &#123;
//		if (it-&gt;x &gt;= WIN_WIDTH + (it-&gt;img).getwidth() || it-&gt;x &lt; -(it-&gt;img).getwidth()) &#123;
//			//it-&gt;exist = false;
//			it-&gt;x = WIN_WIDTH + (it-&gt;img).getwidth() - 30;
//		&#125;
//	&#125;
//&#125;
void attack_lion();
void fly() &#123;
    for (int i = 0; i &lt; 3; i++) &#123;
        bgX[i] -= bgSpeed[i];
        if (bgX[i] &lt; -WIN_WIDTH) &#123;
            bgX[i] = 0;
        &#125;
    &#125;
    if (heroJump) &#123;
        if (heroY &lt; jumpHeightMax) &#123;
            heroJumpOff = 4;
        &#125;
        heroY += heroJumpOff;
        if (heroY &gt; 345 - imgHeros[0].getheight()) &#123;
            heroJump = false;
            heroJumpOff = -4;
        &#125;
    &#125;
    else if(heroDown)&#123;
        static int count = 0;
        int delays[2] = &#123; 4,35 &#125;;
        count++;
        if (count &gt;= delays[heroIndex]) &#123;
            count = 0;
            heroIndex++;
            if (heroIndex &gt;= 2) &#123;
                heroIndex = 0;
                heroDown = false;
            &#125;
        &#125;
        
    &#125;else&#123;
        heroIndex = (heroIndex + 1) % 12;
    &#125;
    static int frameCount = 0;
    static int enemyFre = 50;
    frameCount++;
    if (frameCount &gt; enemyFre) &#123;
        frameCount = 0;
        enemyFre = 50 + rand() % 50;
        createObstacle();
    &#125;
    //if (torToiseExist) &#123;
    //	torToiseX -= bgSpeed[2];
    //	if (torToiseX &lt; -imgTortoise.getwidth()) &#123;
    //		torToiseExist = false;
    //	&#125;
    //&#125;

    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist) &#123;
            obstacles[i].x -= obstacles[i].speed + bgSpeed[2];
            if (obstacles[i].x &lt; -obstacleImgs[obstacles[i].type][0].getwidth() * 2) &#123;
                obstacles[i].exist = false;
            &#125;
            int len = obstacleImgs[obstacles[i].type].size();
            obstacles[i].imgIndex = (obstacles[i].imgIndex + 1) % len;
        &#125;
    &#125;
    //for (vector&lt;bullet_t&gt;::iterator it = bullets.begin(); it != bullets.end(); it++) &#123;
    //	it-&gt;x += it-&gt;speed;
    //	if (it-&gt;x &gt;= WIN_WIDTH - (it-&gt;img).getwidth()/2 - 30) &#123;
    //		it-&gt;exist = false;
    //		//bullets.erase(it);
    //		//bullets.erase(it);
    //	&#125;
    //&#125;
    vector&lt;bullet_t&gt;::iterator it = bullets.begin();
    while (it != bullets.end()) &#123;
        it-&gt;x += it-&gt;speed;
        if (it-&gt;x &gt;= WIN_WIDTH - (it-&gt;img).getwidth() / 2 - 30) &#123;
            vector&lt;bullet_t&gt;::iterator temp = it;
            it = bullets.erase(temp);
        &#125;
        else &#123;
            it++;
        &#125;
    &#125;
    //delete_bullet();
    checkHit();
    attack_lion();
&#125;

void updateBg() &#123;
    putimagePNG2(bgX[0], 0, &amp;imgBgs[0]);
    putimagePNG2(bgX[1], 119, &amp;imgBgs[1]);
    putimagePNG2(bgX[2], 330, &amp;imgBgs[2]);
&#125;

void jump() &#123;
    heroJump = true;
    update = true;
&#125;

void down() &#123;
    update = true;
    heroDown = true;
    heroIndex = 0;
&#125;
void attack();
void keyEvent() &#123;
    char ch;
    if (_kbhit()) &#123;
        ch = _getch();
        if (ch == &#39; &#39;) &#123;
            jump();
        &#125;
        else if (ch == &#39;s&#39;) &#123;
            down();
        &#125;
        else if (ch == &#39;k&#39;) &#123;
            attack();
        &#125;
    &#125;
&#125;

void updateEnemy() &#123;
    //if (torToiseExist) &#123;
    //	putimagePNG2(torToiseX,torToiseY,WIN_WIDTH,&amp;imgTortoise);
    //&#125;
    //delete_bullet();
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist) &#123;
            putimagePNG2(obstacles[i].x, obstacles[i].y, WIN_WIDTH, &amp;obstacleImgs[obstacles[i].type][obstacles[i].imgIndex]);
        &#125;
    &#125;
&#125;
void attack_lion() &#123;
    //vector&lt;bullet_t&gt;::iterator it = bullets.begin();
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].type == LION &amp;&amp; obstacles[i].exist) &#123;
            vector&lt;bullet_t&gt;::iterator it = bullets.begin();
            while (it != bullets.end()) &#123;
                int a1x, a1y, a2x, a2y;
                
                int off = 15;
                a1x = it-&gt;x + off;
                a1y = it-&gt;y + off;
                a2x = it-&gt;x + (it-&gt;img).getwidth() - off;
                a2y = it-&gt;y + (it-&gt;img).getheight();
                IMAGE img = obstacleImgs[obstacles[i].type][obstacles[i].imgIndex];
                int b1x = obstacles[i].x + off;
                int b1y = obstacles[i].y + off;
                int b2x = obstacles[i].x + img.getwidth() - off;
                int b2y = obstacles[i].y + img.getheight() - 10;

                if (rectIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y)) &#123;
                    /*vector&lt;bullet_t&gt;::iterator temp = it;
                    it = bullets.erase(temp);*/
                    obstacles[i].exist = false;
                    //playSound(&quot;res/hit.mp3&quot;);
                    it = bullets.erase(it);
                    break;
                &#125;
                else &#123;
                    it++;
                &#125;
                
            &#125;
        &#125;
    &#125;
&#125;
void updateHero() &#123;
    if (!heroDown) &#123;
        putimagePNG2(heroX, heroY, &amp;imgHeros[heroIndex]);
    &#125;
    else &#123;
        int y = 345 - imgHeroDown[heroIndex].getheight();
        putimagePNG2(heroX, y, &amp;imgHeroDown[heroIndex]);
    &#125;
&#125;

void updateBloodBar() &#123;
    drawBloodBar(10, 10, 200, 10, 2, BLUE, DARKGRAY, RED, heroBlood / 100.0);
&#125;

void checkOver() &#123;
    if (heroBlood &lt;= 0) &#123;
        loadimage(0, &quot;res/over.png&quot;);
        FlushBatchDraw();
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);
        system(&quot;pause&quot;);

        heroBlood = 100;
        score = 0;
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;

void checkScore() &#123;
    for (int i = 0; i &lt; OBSTACLE_COUNT; i++) &#123;
        if (obstacles[i].exist &amp;&amp; 
            obstacles[i].passed == false &amp;&amp; 
            obstacles[i].hited == false&amp;&amp;
            obstacles[i].x + obstacleImgs[obstacles[i].type][0].getwidth() &lt; heroX) &#123;
            score++;
            obstacles[i].passed = true;
            printf(&quot;score:%d\n&quot;, score);
        &#125;
    &#125;

&#125;

void updateScore() &#123;
    char str[8];
    sprintf(str, &quot;%d&quot;, score);
    
    int x = 20;
    int y = 25;

    for (int i = 0; str[i]; i++) &#123;
        int sz = str[i] - &#39;0&#39;;
        putimagePNG(x, y, &amp;imgSZ[sz]);
        x += imgSZ[sz].getwidth() + 5;
    &#125;
&#125;

void checkWin() &#123;
    if (score &gt;= WIN_SCORE) &#123;
        FlushBatchDraw();
        mciSendString(&quot;play res/win.mp3&quot;, 0, 0, 0);
        Sleep(2000);
        loadimage(0, &quot;res/win.png&quot;);
        FlushBatchDraw();
        mciSendString(&quot;stop res/bg.mp3&quot;, 0, 0, 0);
        system(&quot;pause&quot;);
        heroBlood = 100;
        score = 0;
        mciSendString(&quot;play res/bg.mp3 repeat&quot;, 0, 0, 0);
    &#125;
&#125;

void updatebullet() &#123;
    //delete_bullet();
    for (vector&lt;bullet_t&gt;::iterator it = bullets.begin(); it != bullets.end(); it++) &#123;
        //if (it-&gt;exist) &#123;
            putimagePNG2(it-&gt;x, it-&gt;y, &amp;(it-&gt;img));
        //&#125;
    &#125;
&#125;
void attack() &#123;
    bullet_t bullet;
    loadimage(&amp;bullet.img, &quot;res/t7.png&quot;);
    bullet.x = heroX + imgHeros[heroIndex].getwidth();
    bullet.y = heroY + imgHeros[heroIndex].getheight() / 2;
    bullet.speed = 6;
    //bullet.exist = true;
    bullets.push_back(bullet);
    //attack_lion();
&#125;
int main(void) &#123;
    init();

    loadimage(0, &quot;res/over.png&quot;);
    system(&quot;pause&quot;);

    int timer = 0;
    while (1) &#123;
        keyEvent();
        timer += getDelay();
        if (timer &gt; 10) &#123;
            timer = 0;
            update = true;
        &#125;
        if (update) &#123;
            update = false;
            BeginBatchDraw();
            updateBg();
            //putimagePNG2(heroX,heroY,&amp;imgHeros[heroIndex]);
            //attack_lion();
            updateHero();
            updateEnemy();
            updatebullet();
            updateBloodBar();
            updateScore();
            //delete_bullet();
            checkWin();
            EndBatchDraw();
            checkOver();
            checkScore();
            fly();
            //attack();
        &#125;
        //Sleep(3);
    &#125;
    system(&quot;pause&quot;);
    return 0;
&#125;

</code></pre>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：</li>
        <li>Post author：LiXiJian</li>
        <li>Create time：2023-01-17 15:31:21</li>
        <li>
            Post link：https://redefine.evanluo.top/2023/01/17/天天酷跑（c语言游戏项目）/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/01/17/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98%EF%BC%88c%E8%AF%AD%E8%A8%80%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%EF%BC%89/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item"></span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                </div>
            

            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div style="font-size: 1.3rem;margin-top: 0; margin-bottom: 0.8rem; transition-duration: 0.1s;"><i class="fa-solid fa-list"></i> <strong>Contents</strong></div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#title-%E5%A4%A9%E5%A4%A9%E9%85%B7%E8%B7%91%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97"><span class="nav-text">title:天天酷跑开发日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE"><span class="nav-text">1.创建项目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%8E%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="nav-text">2.头文件与常量定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">3.全局变量和结构体定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%B8%B8%E6%88%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4.游戏初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#preLoadSound-%E5%87%BD%E6%95%B0"><span class="nav-text">preLoadSound()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E7%94%BB%E9%9D%A2%EF%BC%8C%E4%BA%BA%E7%89%A9%EF%BC%8C%E6%95%8C%E4%BA%BA%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="nav-text">5.画面，人物，敌人动起来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF"><span class="nav-text">实现游戏背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%BA%BA%E7%89%A9%E8%B7%B3%E8%B7%83%E4%B8%8B%E8%B9%B2"><span class="nav-text">实现人物跳跃下蹲</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JUMP"><span class="nav-text">JUMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DOWN"><span class="nav-text">DOWN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%8C%E4%BA%BA"><span class="nav-text">创建敌人</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87"><span class="nav-text">优化障碍物的出现频率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%8C%E4%BA%BA%E5%8A%A8%E8%B5%B7%E6%9D%A5"><span class="nav-text">敌人动起来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8B"><span class="nav-text">碰撞检测</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rectIntersect%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0"><span class="nav-text">rectIntersect（）函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#playSound-%E5%87%BD%E6%95%B0"><span class="nav-text">playSound()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%B8%B2%E6%9F%93%E6%B8%B8%E6%88%8F%E5%85%83%E7%B4%A0"><span class="nav-text">6.渲染游戏元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%B8%B8%E6%88%8F%E8%83%8C%E6%99%AF"><span class="nav-text">渲染游戏背景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#putimagePNG2-%E5%87%BD%E6%95%B0"><span class="nav-text">putimagePNG2()函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E6%95%8C%E4%BA%BA"><span class="nav-text">渲染敌人</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B8%B2%E6%9F%93%E8%A7%92%E8%89%B2"><span class="nav-text">渲染角色</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E6%8E%A7%E5%88%B6%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5"><span class="nav-text">7.控制键盘输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E6%98%BE%E7%A4%BA%E8%A1%80%E6%9D%A1"><span class="nav-text">8.显示血条</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%BB%93%E6%9D%9F%E5%88%A4%E6%96%AD"><span class="nav-text">9.结束判断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%98%BE%E7%A4%BA%E5%88%86%E6%95%B0"><span class="nav-text">10.显示分数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E5%88%A4%E6%96%AD%E6%B8%B8%E6%88%8F%E8%83%9C%E5%88%A9"><span class="nav-text">11.判断游戏胜利</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E4%BC%98%E5%8C%96%E5%B8%A7%E7%AD%89%E5%BE%85"><span class="nav-text">12.优化帧等待</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#getDelay-%E5%87%BD%E6%95%B0"><span class="nav-text">getDelay()函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E8%BD%AF%E4%BB%B6%E6%89%93%E5%8C%85"><span class="nav-text">13.软件打包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%B7%BB%E5%8A%A0%E8%8B%B1%E9%9B%84%E6%8A%80%E8%83%BD"><span class="nav-text">14.添加英雄技能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%A4%A7%E6%8A%80%E8%83%BD"><span class="nav-text">变大技能</span></a></li></ol></li></ol>
    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;<i class="fa-solid fa-heart icon-animate"></i>&nbsp;<a href="/">LiXiJian. All Rights Reserved.</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalviews&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v0.4.4</a>
        </div>
        
        
        <script async data-pjax defer>
            function odometer_init(){
                    let el = document.getElementsByClassName('odometer');
                    for (i = 0; i < el.length; i++) {
                        od = new Odometer({
                            el: el[i],
                            format: '( ddd).dd',
                            duration: 200
                        });
                    }
            }
            odometer_init();
        </script>
        <div id="start_time_div" style="display:none">
            2022/12/31 16:45:14
        </div>
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fa-solid fa-magnifying-glass-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fa-solid fa-magnifying-glass-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fa-solid fa-left-right"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fa-solid fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fa-solid fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fa-solid fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fa-solid fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>





    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>




    
<script src="/js/runtime.js"></script>

    
<script src="/js/odometer.min.js"></script>

    
<link rel="stylesheet" href="/css/odometer-theme-minimal.css">



<div class="post-scripts pjax">
    
        
<script src="/js/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>



</body>
</html>
